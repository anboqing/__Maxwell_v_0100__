!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABQ	include/Log.hpp	/^namespace ABQ{$/;"	n
Args	include/json/value.h	/^      typedef std::vector<PathArgument> Args;$/;"	t	class:Json::Path
ArgvContext	include/CppJieba/Limonp/ArgvContext.hpp	/^            ArgvContext(int argc, const char* const * argv)$/;"	f	class:Limonp::ArgvContext
ArgvContext	include/CppJieba/Limonp/ArgvContext.hpp	/^    class ArgvContext$/;"	c	namespace:Limonp
ArrayIndex	include/json/value.h	/^      typedef UInt ArrayIndex;$/;"	t	class:Json::Value
ArrayIndex	include/json/value.h	/^      typedef Value::ArrayIndex ArrayIndex;$/;"	t	class:Json::ValueInternalArray
B	include/CppJieba/HMMSegment.hpp	/^            enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:CppJieba::HMMSegment::__anon2
BACKLOG	src/fork_server.cpp	26;"	d	file:
BYTE	include/CppJieba/Limonp/Md5.hpp	/^typedef unsigned char BYTE ;$/;"	t	namespace:Limonp
BlockingQueue	include/CppJieba/Limonp/BlockingQueue.hpp	/^                BlockingQueue()$/;"	f	class:Limonp::BlockingQueue
BlockingQueue	include/CppJieba/Limonp/BlockingQueue.hpp	/^        class BlockingQueue: NonCopyable$/;"	c	namespace:Limonp
BoundedBlockingQueue	include/CppJieba/Limonp/BlockingQueue.hpp	/^                explicit BoundedBlockingQueue(size_t maxSize)$/;"	f	class:Limonp::BoundedBlockingQueue
BoundedBlockingQueue	include/CppJieba/Limonp/BlockingQueue.hpp	/^        class BoundedBlockingQueue : NonCopyable$/;"	c	namespace:Limonp
BoundedQueue	include/CppJieba/Limonp/BoundedQueue.hpp	/^                explicit BoundedQueue(size_t capacity): capacity_(capacity), circular__buffer(capacity)$/;"	f	class:Limonp::BoundedQueue
BoundedQueue	include/CppJieba/Limonp/BoundedQueue.hpp	/^        class BoundedQueue$/;"	c	namespace:Limonp
BucketIndex	include/json/value.h	/^      typedef unsigned int BucketIndex;$/;"	t	class:Json::ValueInternalMap
CPPJIBEA_HMMSEGMENT_H	include/CppJieba/HMMSegment.hpp	2;"	d
CPPJIEBA_DICT_TRIE_HPP	include/CppJieba/DictTrie.hpp	2;"	d
CPPJIEBA_FULLSEGMENT_H	include/CppJieba/FullSegment.hpp	2;"	d
CPPJIEBA_KEYWORD_EXTRACTOR_H	include/CppJieba/KeywordExtractor.hpp	2;"	d
CPPJIEBA_MIXSEGMENT_H	include/CppJieba/MixSegment.hpp	2;"	d
CPPJIEBA_MPSEGMENT_H	include/CppJieba/MPSegment.hpp	6;"	d
CPPJIEBA_POS_TAGGING_H	include/CppJieba/PosTagger.hpp	2;"	d
CPPJIEBA_QUERYSEGMENT_H	include/CppJieba/QuerySegment.hpp	2;"	d
CPPJIEBA_SEGMENTBASE_H	include/CppJieba/SegmentBase.hpp	2;"	d
CPPJIEBA_SEGMENTINTERFACE_H	include/CppJieba/ISegment.hpp	2;"	d
CPPJIEBA_TRANSCODE_H	include/CppJieba/TransCode.hpp	6;"	d
CPPJIEBA_TRIE_HPP	include/CppJieba/Trie.hpp	2;"	d
CPPTL_AUTOLINK_DLL	include/json/autolink.h	12;"	d
CPPTL_AUTOLINK_DLL	include/json/autolink.h	14;"	d
CPPTL_AUTOLINK_NAME	include/json/autolink.h	11;"	d
CPPTL_JSON_FEATURES_H_INCLUDED	include/json/features.h	2;"	d
CPPTL_JSON_H_INCLUDED	include/json/value.h	2;"	d
CPPTL_JSON_READER_H_INCLUDED	include/json/reader.h	2;"	d
CSTR_BUFFER_SIZE	include/CppJieba/Limonp/Logger.hpp	/^    enum {LL_DEBUG = 0, LL_INFO = 1, LL_WARN = 2, LL_ERROR = 3, LL_FATAL = 4, LEVEL_ARRAY_SIZE = 5, CSTR_BUFFER_SIZE = 32};$/;"	e	enum:Limonp::__anon1
CZString	include/json/value.h	/^      class CZString $/;"	c	class:Json::Value
CastFloat	include/CppJieba/Limonp/CastFloat.hpp	/^    namespace CastFloat$/;"	n	namespace:Limonp
Char	include/json/reader.h	/^      typedef char Char;$/;"	t	class:Json::Reader
ChildValues	include/json/writer.h	/^      typedef std::vector<std::string> ChildValues;$/;"	t	class:Json::StyledStreamWriter
ChildValues	include/json/writer.h	/^      typedef std::vector<std::string> ChildValues;$/;"	t	class:Json::StyledWriter
CodeConverter	include/CppJieba/Limonp/CodeConverter.hpp	/^            CodeConverter(const char *from_charset,const char *to_charset) $/;"	f	class:Limonp::CodeConverter
CodeConverter	include/CppJieba/Limonp/CodeConverter.hpp	/^    class CodeConverter$/;"	c	namespace:Limonp
CommentInfo	include/json/value.h	/^      struct CommentInfo$/;"	s	class:Json::Value
CommentPlacement	include/json/value.h	/^   enum CommentPlacement$/;"	g	namespace:Json
Condition	include/Condition.h	/^    Condition(MutexLock& lock):_cond_lock(lock){$/;"	f	class:Condition
Condition	include/Condition.h	/^class Condition:public Uncopyable{$/;"	c
Condition	include/CppJieba/Limonp/Condition.hpp	/^            explicit Condition(MutexLock& mutex)$/;"	f	class:Limonp::Condition
Condition	include/CppJieba/Limonp/Condition.hpp	/^    class Condition : NonCopyable$/;"	c	namespace:Limonp
Config	include/CppJieba/Limonp/Config.hpp	/^            explicit Config(const string& filePath)$/;"	f	class:Limonp::Config
Config	include/CppJieba/Limonp/Config.hpp	/^    class Config$/;"	c	namespace:Limonp
Configure	include/Configure.h	/^class Configure:public Uncopyable{$/;"	c
Configure	src/Configure.cpp	/^Configure::Configure(const std::string& conf_file_name){$/;"	f	class:Configure
CppJieba	include/CppJieba/DictTrie.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/FullSegment.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/HMMSegment.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/ISegment.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/KeywordExtractor.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/MPSegment.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/MixSegment.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/PosTagger.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/QuerySegment.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/SegmentBase.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/TransCode.hpp	/^namespace CppJieba$/;"	n
CppJieba	include/CppJieba/Trie.hpp	/^namespace CppJieba$/;"	n
CreateTask	include/CppJieba/Limonp/ThreadPool.hpp	/^        ITask* CreateTask(ArgType arg) $/;"	f	namespace:Limonp
CreateTask	include/CppJieba/Limonp/ThreadPool.hpp	/^        ITask* CreateTask(ArgType0 arg0, ArgType1 arg1) $/;"	f	namespace:Limonp
DICT_COLUMN_NUM	include/CppJieba/DictTrie.hpp	/^    const size_t DICT_COLUMN_NUM = 3;$/;"	m	namespace:CppJieba
DagType	include/CppJieba/DictTrie.hpp	/^    typedef map<size_t, const DictUnit*> DagType;$/;"	t	namespace:CppJieba
Decode	include/CppJieba/Limonp/Md5.hpp	/^  static void Decode( UINT4 *output, unsigned char *input, unsigned int len )$/;"	f	class:Limonp::MD5
DictTrie	include/CppJieba/DictTrie.hpp	/^            DictTrie()$/;"	f	class:CppJieba::DictTrie
DictTrie	include/CppJieba/DictTrie.hpp	/^            DictTrie(const string& dictPath, const string& userDictPath = "")$/;"	f	class:CppJieba::DictTrie
DictTrie	include/CppJieba/DictTrie.hpp	/^    class DictTrie$/;"	c	namespace:CppJieba
DictUnit	include/CppJieba/DictTrie.hpp	/^    struct DictUnit$/;"	s	namespace:CppJieba
Diction	include/Diction.h	/^class Diction:public Uncopyable{$/;"	c
Diction	src/Diction.cpp	/^Diction::Diction():_dict_vec(){$/;"	f	class:Diction
DuplicationPolicy	include/json/value.h	/^         enum DuplicationPolicy $/;"	g	class:Json::Value::CZString
E	include/CppJieba/HMMSegment.hpp	/^            enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:CppJieba::HMMSegment::__anon2
EmitProbMap	include/CppJieba/HMMSegment.hpp	/^    typedef unordered_map<uint16_t, double> EmitProbMap;$/;"	t	namespace:CppJieba
Encode	include/CppJieba/Limonp/Md5.hpp	/^  static void Encode( unsigned char *output, UINT4 *input, unsigned int len )$/;"	f	class:Limonp::MD5
ErrorInfo	include/json/reader.h	/^      class ErrorInfo$/;"	c	class:Json::Reader
Errors	include/json/reader.h	/^      typedef std::deque<ErrorInfo> Errors;$/;"	t	class:Json::Reader
F	include/CppJieba/Limonp/Md5.hpp	58;"	d
FF	include/CppJieba/Limonp/Md5.hpp	68;"	d
FILE_BASENAME	include/CppJieba/Limonp/Logger.hpp	19;"	d
FILE_BASENAME	include/Log.hpp	20;"	d
FastWriter	include/json/writer.h	/^   class JSON_API FastWriter : public Writer$/;"	c	namespace:Json
Features	include/json/features.h	/^   class JSON_API Features$/;"	c	namespace:Json
Final	include/CppJieba/Limonp/Md5.hpp	/^  void Final()$/;"	f	class:Limonp::MD5
FullSegment	include/CppJieba/FullSegment.hpp	/^            FullSegment()$/;"	f	class:CppJieba::FullSegment
FullSegment	include/CppJieba/FullSegment.hpp	/^            explicit FullSegment(const DictTrie* dictTrie) $/;"	f	class:CppJieba::FullSegment
FullSegment	include/CppJieba/FullSegment.hpp	/^            explicit FullSegment(const string& dictPath)$/;"	f	class:CppJieba::FullSegment
FullSegment	include/CppJieba/FullSegment.hpp	/^    class FullSegment: public SegmentBase$/;"	c	namespace:CppJieba
G	include/CppJieba/Limonp/Md5.hpp	59;"	d
GG	include/CppJieba/Limonp/Md5.hpp	73;"	d
H	include/CppJieba/Limonp/Md5.hpp	60;"	d
HH	include/CppJieba/Limonp/Md5.hpp	78;"	d
HMMSegment	include/CppJieba/HMMSegment.hpp	/^            HMMSegment(){}$/;"	f	class:CppJieba::HMMSegment
HMMSegment	include/CppJieba/HMMSegment.hpp	/^            explicit HMMSegment(const string& filePath)$/;"	f	class:CppJieba::HMMSegment
HMMSegment	include/CppJieba/HMMSegment.hpp	/^    class HMMSegment: public SegmentBase$/;"	c	namespace:CppJieba
HashKey	include/json/value.h	/^      typedef unsigned int HashKey;$/;"	t	class:Json::ValueInternalMap
HeapData4Query	include/Query.h	/^    HeapData4Query(int dis,int index):_distance(dis),_index(index){}$/;"	f	class:HeapData4Query
HeapData4Query	include/Query.h	/^class HeapData4Query{$/;"	c
I	include/CppJieba/Limonp/Md5.hpp	61;"	d
II	include/CppJieba/Limonp/Md5.hpp	83;"	d
ISegment	include/CppJieba/ISegment.hpp	/^    class ISegment$/;"	c	namespace:CppJieba
ITask	include/CppJieba/Limonp/ThreadPool.hpp	/^    class ITask$/;"	c	namespace:Limonp
IThread	include/CppJieba/Limonp/Thread.hpp	/^            IThread(): isStarted(false), isJoined(false)$/;"	f	class:Limonp::IThread
IThread	include/CppJieba/Limonp/Thread.hpp	/^    class IThread: NonCopyable$/;"	c	namespace:Limonp
InArgs	include/json/value.h	/^      typedef std::vector<const PathArgument *> InArgs;$/;"	t	class:Json::Path
Index	include/Index.h	/^class Index:public Uncopyable{$/;"	c
Index	src/Index.cpp	/^Index::Index():_index_hashmap(){$/;"	f	class:Index
Init	include/CppJieba/Limonp/Md5.hpp	/^  void Init()$/;"	f	class:Limonp::MD5
InitOnOff	include/CppJieba/Limonp/InitOnOff.hpp	/^            InitOnOff():isInited_(false){};$/;"	f	class:Limonp::InitOnOff
InitOnOff	include/CppJieba/Limonp/InitOnOff.hpp	/^    class InitOnOff$/;"	c	namespace:Limonp
Int	include/json/forwards.h	/^   typedef int Int;$/;"	t	namespace:Json
Int	include/json/value.h	/^      typedef Json::Int Int;$/;"	t	class:Json::Value
InternalFlags	include/json/value.h	/^      enum InternalFlags { $/;"	g	class:Json::ValueInternalLink
IteratorState	include/json/value.h	/^         IteratorState() $/;"	f	struct:Json::ValueInternalArray::IteratorState
IteratorState	include/json/value.h	/^         IteratorState() $/;"	f	struct:Json::ValueInternalMap::IteratorState
IteratorState	include/json/value.h	/^      struct IteratorState \/\/ Must be a POD$/;"	s	class:Json::ValueInternalArray
IteratorState	include/json/value.h	/^      struct IteratorState$/;"	s	class:Json::ValueInternalMap
JSON_API	include/json/config.h	34;"	d
JSON_API	include/json/config.h	36;"	d
JSON_API	include/json/config.h	38;"	d
JSON_API	include/json/config.h	40;"	d
JSON_AUTOLINK_H_INCLUDED	include/json/autolink.h	2;"	d
JSON_CONFIG_H_INCLUDED	include/json/config.h	2;"	d
JSON_FORWARDS_H_INCLUDED	include/json/forwards.h	2;"	d
JSON_JSON_H_INCLUDED	include/json/json.h	2;"	d
JSON_USE_CPPTL	include/json/config.h	29;"	d
JSON_USE_EXCEPTION	include/json/config.h	24;"	d
JSON_WRITER_H_INCLUDED	include/json/writer.h	2;"	d
Json	include/json/features.h	/^namespace Json {$/;"	n
Json	include/json/forwards.h	/^namespace Json {$/;"	n
Json	include/json/reader.h	/^namespace Json {$/;"	n
Json	include/json/value.h	/^namespace Json {$/;"	n
Json	include/json/writer.h	/^namespace Json {$/;"	n
KeyMapType	include/CppJieba/Trie.hpp	/^                typedef unordered_map<KeyType, TrieNode<KeyType, ValueType>* > KeyMapType;$/;"	t	class:CppJieba::TrieNode
KeywordExtractor	include/CppJieba/KeywordExtractor.hpp	/^            KeywordExtractor(){};$/;"	f	class:CppJieba::KeywordExtractor
KeywordExtractor	include/CppJieba/KeywordExtractor.hpp	/^            KeywordExtractor(const string& dictPath, const string& hmmFilePath, const string& idfPath, const string& stopWordPath)$/;"	f	class:CppJieba::KeywordExtractor
KeywordExtractor	include/CppJieba/KeywordExtractor.hpp	/^    class KeywordExtractor$/;"	c	namespace:CppJieba
Kind	include/json/value.h	/^      enum Kind$/;"	g	class:Json::PathArgument
LEVEL_ARRAY_SIZE	include/CppJieba/Limonp/Logger.hpp	/^    enum {LL_DEBUG = 0, LL_INFO = 1, LL_WARN = 2, LL_ERROR = 3, LL_FATAL = 4, LEVEL_ARRAY_SIZE = 5, CSTR_BUFFER_SIZE = 32};$/;"	e	enum:Limonp::__anon1
LIMONP_ARGV_FUNCTS_H	include/CppJieba/Limonp/ArgvContext.hpp	7;"	d
LIMONP_BLOCKINGQUEUE_HPP	include/CppJieba/Limonp/BlockingQueue.hpp	6;"	d
LIMONP_BOUNDED_QUEUE_HPP	include/CppJieba/Limonp/BoundedQueue.hpp	2;"	d
LIMONP_CAST_FUNCTS_H	include/CppJieba/Limonp/CastFloat.hpp	2;"	d
LIMONP_CHECK	include/CppJieba/Limonp/HandyMacro.hpp	7;"	d
LIMONP_CODE_CONVERTER_HPP	include/CppJieba/Limonp/CodeConverter.hpp	2;"	d
LIMONP_CONDITION_HPP	include/CppJieba/Limonp/Condition.hpp	6;"	d
LIMONP_CONFIG_H	include/CppJieba/Limonp/Config.hpp	6;"	d
LIMONP_HANDY_MACRO_HPP	include/CppJieba/Limonp/HandyMacro.hpp	2;"	d
LIMONP_INITONOFF_H	include/CppJieba/Limonp/InitOnOff.hpp	2;"	d
LIMONP_LOCAL_VECTOR_HPP	include/CppJieba/Limonp/LocalVector.hpp	2;"	d
LIMONP_LOGGER_H	include/CppJieba/Limonp/Logger.hpp	6;"	d
LIMONP_MUTEX_LOCK_HPP	include/CppJieba/Limonp/MutexLock.hpp	2;"	d
LIMONP_MYSQLCLIENT_H	include/CppJieba/Limonp/MysqlClient.hpp	2;"	d
LIMONP_NONCOPYABLE_H	include/CppJieba/Limonp/NonCopyable.hpp	4;"	d
LIMONP_STD_EXTEMSION_HPP	include/CppJieba/Limonp/StdExtension.hpp	2;"	d
LIMONP_STR_FUNCTS_H	include/CppJieba/Limonp/StringUtil.hpp	6;"	d
LIMONP_THREAD_HPP	include/CppJieba/Limonp/Thread.hpp	2;"	d
LIMONP_THREAD_POOL_HPP	include/CppJieba/Limonp/ThreadPool.hpp	2;"	d
LL_DEBUG	include/CppJieba/Limonp/Logger.hpp	/^    enum {LL_DEBUG = 0, LL_INFO = 1, LL_WARN = 2, LL_ERROR = 3, LL_FATAL = 4, LEVEL_ARRAY_SIZE = 5, CSTR_BUFFER_SIZE = 32};$/;"	e	enum:Limonp::__anon1
LL_ERROR	include/CppJieba/Limonp/Logger.hpp	/^    enum {LL_DEBUG = 0, LL_INFO = 1, LL_WARN = 2, LL_ERROR = 3, LL_FATAL = 4, LEVEL_ARRAY_SIZE = 5, CSTR_BUFFER_SIZE = 32};$/;"	e	enum:Limonp::__anon1
LL_FATAL	include/CppJieba/Limonp/Logger.hpp	/^    enum {LL_DEBUG = 0, LL_INFO = 1, LL_WARN = 2, LL_ERROR = 3, LL_FATAL = 4, LEVEL_ARRAY_SIZE = 5, CSTR_BUFFER_SIZE = 32};$/;"	e	enum:Limonp::__anon1
LL_INFO	include/CppJieba/Limonp/Logger.hpp	/^    enum {LL_DEBUG = 0, LL_INFO = 1, LL_WARN = 2, LL_ERROR = 3, LL_FATAL = 4, LEVEL_ARRAY_SIZE = 5, CSTR_BUFFER_SIZE = 32};$/;"	e	enum:Limonp::__anon1
LL_WARN	include/CppJieba/Limonp/Logger.hpp	/^    enum {LL_DEBUG = 0, LL_INFO = 1, LL_WARN = 2, LL_ERROR = 3, LL_FATAL = 4, LEVEL_ARRAY_SIZE = 5, CSTR_BUFFER_SIZE = 32};$/;"	e	enum:Limonp::__anon1
LOCAL_VECTOR_BUFFER_SIZE	include/CppJieba/Limonp/LocalVector.hpp	/^    const size_t LOCAL_VECTOR_BUFFER_SIZE = 16;$/;"	m	namespace:Limonp
LOG_FORMAT	include/CppJieba/Limonp/Logger.hpp	/^    static const char * LOG_FORMAT = "%s %s:%d %s %s\\n";$/;"	m	namespace:Limonp
LOG_LEVEL_ARRAY	include/CppJieba/Limonp/Logger.hpp	/^    static const char * LOG_LEVEL_ARRAY[LEVEL_ARRAY_SIZE]= {"DEBUG","INFO","WARN","ERROR","FATAL"};$/;"	m	namespace:Limonp
LOG_TIME_FORMAT	include/CppJieba/Limonp/Logger.hpp	/^    static const char * LOG_TIME_FORMAT = "%Y-%m-%d %H:%M:%S";$/;"	m	namespace:Limonp
Limonp	include/CppJieba/Limonp/ArgvContext.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/BlockingQueue.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/BoundedQueue.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/CastFloat.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/CodeConverter.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/Condition.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/Config.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/InitOnOff.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/LocalVector.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/Logger.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/Md5.hpp	/^namespace Limonp $/;"	n
Limonp	include/CppJieba/Limonp/MutexLock.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/MysqlClient.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/NonCopyable.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/StringUtil.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/Thread.hpp	/^namespace Limonp$/;"	n
Limonp	include/CppJieba/Limonp/ThreadPool.hpp	/^namespace Limonp$/;"	n
LocalVector	include/CppJieba/Limonp/LocalVector.hpp	/^                LocalVector()$/;"	f	class:Limonp::LocalVector
LocalVector	include/CppJieba/Limonp/LocalVector.hpp	/^                LocalVector(const LocalVector<T>& vec)$/;"	f	class:Limonp::LocalVector
LocalVector	include/CppJieba/Limonp/LocalVector.hpp	/^                LocalVector(const_iterator  begin, const_iterator end) \/\/ TODO: make it faster$/;"	f	class:Limonp::LocalVector
LocalVector	include/CppJieba/Limonp/LocalVector.hpp	/^                LocalVector(size_t size, const T& t) \/\/ TODO: make it faster$/;"	f	class:Limonp::LocalVector
LocalVector	include/CppJieba/Limonp/LocalVector.hpp	/^        class LocalVector$/;"	c	namespace:Limonp
Location	include/json/reader.h	/^      typedef const Char *Location;$/;"	t	class:Json::Reader
LockBase	include/Lock.h	/^    LockBase(){}$/;"	f	class:LockBase
LockBase	include/Lock.h	/^class LockBase:public Uncopyable{$/;"	c
LockSafeGuard	include/Lock.h	/^    LockSafeGuard(LockBase& lock,const int flag = 0):_lock(lock){$/;"	f	class:LockSafeGuard
LockSafeGuard	include/Lock.h	/^class LockSafeGuard:public Uncopyable{$/;"	c
Log	include/Log.hpp	/^class Log:public Uncopyable{$/;"	c	namespace:ABQ
LogDebug	include/CppJieba/Limonp/Logger.hpp	21;"	d
LogError	include/CppJieba/Limonp/Logger.hpp	24;"	d
LogFatal	include/CppJieba/Limonp/Logger.hpp	25;"	d
LogInfo	include/CppJieba/Limonp/Logger.hpp	22;"	d
LogWarn	include/CppJieba/Limonp/Logger.hpp	23;"	d
Logger	include/CppJieba/Limonp/Logger.hpp	/^    class Logger$/;"	c	namespace:Limonp
Logging	include/CppJieba/Limonp/Logger.hpp	/^            static void Logging(size_t level, const string& msg, const char* fileName, int lineno)$/;"	f	class:Limonp::Logger
Logging	include/Log.hpp	/^    static void Logging(size_t level,const std::string& filename,int lineno,const std::string& fmt,...){$/;"	f	class:ABQ::Log
LoggingF	include/CppJieba/Limonp/Logger.hpp	/^            static void LoggingF(size_t level, const char* fileName, int lineno, const char* const fmt, ...)$/;"	f	class:Limonp::Logger
M	include/CppJieba/HMMSegment.hpp	/^            enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:CppJieba::HMMSegment::__anon2
MAP_TYPE	src/IndexBuilder.cpp	/^typedef map<string,set<size_t> > MAP_TYPE;$/;"	t	file:
MAX_DOUBLE	include/CppJieba/DictTrie.hpp	/^    const double MAX_DOUBLE = 3.14e+100;$/;"	m	namespace:CppJieba
MD5	include/CppJieba/Limonp/Md5.hpp	/^  MD5()$/;"	f	class:Limonp::MD5
MD5	include/CppJieba/Limonp/Md5.hpp	/^class MD5$/;"	c	namespace:Limonp
MD5Transform	include/CppJieba/Limonp/Md5.hpp	/^  static void MD5Transform( UINT4 state[4], unsigned char block[64] )$/;"	f	class:Limonp::MD5
MIN_DOUBLE	include/CppJieba/DictTrie.hpp	/^    const double MIN_DOUBLE = -3.14e+100;$/;"	m	namespace:CppJieba
MPSegment	include/CppJieba/MPSegment.hpp	/^            MPSegment(){};$/;"	f	class:CppJieba::MPSegment
MPSegment	include/CppJieba/MPSegment.hpp	/^            MPSegment(const string& dictPath, const string& userDictPath = "")$/;"	f	class:CppJieba::MPSegment
MPSegment	include/CppJieba/MPSegment.hpp	/^    class MPSegment: public SegmentBase$/;"	c	namespace:CppJieba
Members	include/json/value.h	/^      typedef std::vector<std::string> Members;$/;"	t	class:Json::Value
MixSegment	include/CppJieba/MixSegment.hpp	/^            MixSegment(){};$/;"	f	class:CppJieba::MixSegment
MixSegment	include/CppJieba/MixSegment.hpp	/^            MixSegment(const string& mpSegDict, const string& hmmSegDict, const string& userDict = "")$/;"	f	class:CppJieba::MixSegment
MixSegment	include/CppJieba/MixSegment.hpp	/^    class MixSegment: public SegmentBase$/;"	c	namespace:CppJieba
MutexLock	include/CppJieba/Limonp/MutexLock.hpp	/^            MutexLock()$/;"	f	class:Limonp::MutexLock
MutexLock	include/CppJieba/Limonp/MutexLock.hpp	/^    class MutexLock: NonCopyable$/;"	c	namespace:Limonp
MutexLock	include/Lock.h	/^    MutexLock(){$/;"	f	class:MutexLock
MutexLock	include/Lock.h	/^class MutexLock:public LockBase{$/;"	c
MutexLockGuard	include/CppJieba/Limonp/MutexLock.hpp	/^            explicit MutexLockGuard(MutexLock & mutex)$/;"	f	class:Limonp::MutexLockGuard
MutexLockGuard	include/CppJieba/Limonp/MutexLock.hpp	/^    class MutexLockGuard: NonCopyable$/;"	c	namespace:Limonp
MutexLockGuard	include/CppJieba/Limonp/MutexLock.hpp	54;"	d
MysqlClient	include/CppJieba/Limonp/MysqlClient.hpp	/^            MysqlClient(const string& host, size_t port, const string& user, const string& passwd, const string& db, const string& charset = "utf8"): host_(host), port_(port), user_(user), passwd_(passwd), db_(db), charset_(charset), conn_(NULL)$/;"	f	class:Limonp::MysqlClient
MysqlClient	include/CppJieba/Limonp/MysqlClient.hpp	/^    class MysqlClient: public InitOnOff$/;"	c	namespace:Limonp
Nodes	include/json/reader.h	/^      typedef std::stack<Value *> Nodes;$/;"	t	class:Json::Reader
NonCopyable	include/CppJieba/Limonp/NonCopyable.hpp	/^            NonCopyable(){};$/;"	f	class:Limonp::NonCopyable
NonCopyable	include/CppJieba/Limonp/NonCopyable.hpp	/^    class NonCopyable$/;"	c	namespace:Limonp
ObjectValues	include/json/value.h	/^      typedef CppTL::SmallMap<CZString, Value> ObjectValues;$/;"	t	class:Json::Value
ObjectValues	include/json/value.h	/^      typedef std::map<CZString, Value> ObjectValues;$/;"	t	class:Json::Value
PADDING	include/CppJieba/Limonp/Md5.hpp	/^static unsigned char PADDING[64] = {$/;"	m	namespace:Limonp
POINTER	include/CppJieba/Limonp/Md5.hpp	/^typedef unsigned char *POINTER;$/;"	t	namespace:Limonp
PageIndex	include/json/value.h	/^      typedef unsigned int PageIndex;$/;"	t	class:Json::ValueInternalArray
Path	include/json/value.h	/^   class Path$/;"	c	namespace:Json
PathArgument	include/json/value.h	/^   class PathArgument$/;"	c	namespace:Json
PosTagger	include/CppJieba/PosTagger.hpp	/^            PosTagger(){};$/;"	f	class:CppJieba::PosTagger
PosTagger	include/CppJieba/PosTagger.hpp	/^            PosTagger(const string& dictPath, const string& hmmFilePath, const string& charStatus, const string& startProb, const string& emitProb, const string& endProb, const string& transProb)$/;"	f	class:CppJieba::PosTagger
PosTagger	include/CppJieba/PosTagger.hpp	/^    class PosTagger$/;"	c	namespace:CppJieba
Query	include/Query.h	/^class Query:public Uncopyable{$/;"	c
Query	src/Query.cpp	/^Query::Query(){}$/;"	f	class:Query
QuerySegment	include/CppJieba/QuerySegment.hpp	/^        QuerySegment(){};$/;"	f	class:CppJieba::QuerySegment
QuerySegment	include/CppJieba/QuerySegment.hpp	/^        QuerySegment(const string& dict, const string& model, size_t maxWordLen)$/;"	f	class:CppJieba::QuerySegment
QuerySegment	include/CppJieba/QuerySegment.hpp	/^    class QuerySegment: public SegmentBase$/;"	c	namespace:CppJieba
ROTATE_LEFT	include/CppJieba/Limonp/Md5.hpp	64;"	d
RWLock	include/Lock.h	/^    RWLock(){$/;"	f	class:RWLock
RWLock	include/Lock.h	/^class RWLock:public LockBase{$/;"	c
Reader	include/json/reader.h	/^   class JSON_API Reader$/;"	c	namespace:Json
RowsType	include/CppJieba/Limonp/MysqlClient.hpp	/^            typedef vector< vector<string> > RowsType;$/;"	t	class:Limonp::MysqlClient
S	include/CppJieba/HMMSegment.hpp	/^            enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:CppJieba::HMMSegment::__anon2
S11	include/CppJieba/Limonp/Md5.hpp	39;"	d
S12	include/CppJieba/Limonp/Md5.hpp	40;"	d
S13	include/CppJieba/Limonp/Md5.hpp	41;"	d
S14	include/CppJieba/Limonp/Md5.hpp	42;"	d
S21	include/CppJieba/Limonp/Md5.hpp	43;"	d
S22	include/CppJieba/Limonp/Md5.hpp	44;"	d
S23	include/CppJieba/Limonp/Md5.hpp	45;"	d
S24	include/CppJieba/Limonp/Md5.hpp	46;"	d
S31	include/CppJieba/Limonp/Md5.hpp	47;"	d
S32	include/CppJieba/Limonp/Md5.hpp	48;"	d
S33	include/CppJieba/Limonp/Md5.hpp	49;"	d
S34	include/CppJieba/Limonp/Md5.hpp	50;"	d
S41	include/CppJieba/Limonp/Md5.hpp	51;"	d
S42	include/CppJieba/Limonp/Md5.hpp	52;"	d
S43	include/CppJieba/Limonp/Md5.hpp	53;"	d
S44	include/CppJieba/Limonp/Md5.hpp	54;"	d
SPECIAL_SYMBOL	include/CppJieba/SegmentBase.hpp	/^    const UnicodeValueType SPECIAL_SYMBOL[] = {32u, 9u, 10u, 12290u, 65292u};  $/;"	m	namespace:CppJieba
STATUS_SUM	include/CppJieba/HMMSegment.hpp	/^            enum {B = 0, E = 1, M = 2, S = 3, STATUS_SUM = 4};$/;"	e	enum:CppJieba::HMMSegment::__anon2
SegmentBase	include/CppJieba/SegmentBase.hpp	/^            SegmentBase(){_loadSpecialSymbols();};$/;"	f	class:CppJieba::SegmentBase
SegmentBase	include/CppJieba/SegmentBase.hpp	/^    class SegmentBase: public ISegment, public NonCopyable$/;"	c	namespace:CppJieba
SegmentChar	include/CppJieba/MPSegment.hpp	/^        SegmentChar():uniCh(0), pInfo(NULL), weight(0.0), nextPos(0)$/;"	f	struct:CppJieba::SegmentChar
SegmentChar	include/CppJieba/MPSegment.hpp	/^    struct SegmentChar $/;"	s	namespace:CppJieba
SelfType	include/json/value.h	/^      typedef ValueConstIterator SelfType;$/;"	t	class:Json::ValueConstIterator
SelfType	include/json/value.h	/^      typedef ValueIterator SelfType;$/;"	t	class:Json::ValueIterator
SelfType	include/json/value.h	/^      typedef ValueIteratorBase SelfType;$/;"	t	class:Json::ValueIteratorBase
StaticString	include/json/value.h	/^      explicit StaticString( const char *czstring )$/;"	f	class:Json::StaticString
StaticString	include/json/value.h	/^   class JSON_API StaticString$/;"	c	namespace:Json
StyledStreamWriter	include/json/writer.h	/^   class JSON_API StyledStreamWriter$/;"	c	namespace:Json
StyledWriter	include/json/writer.h	/^   class JSON_API StyledWriter: public Writer$/;"	c	namespace:Json
Task	include/Task.h	/^class Task{$/;"	c
Thread	include/Thread.h	/^class Thread:public Uncopyable{$/;"	c
Thread	src/Thread.cpp	/^Thread::Thread():_tid(0){$/;"	f	class:Thread
ThreadPool	include/CppJieba/Limonp/ThreadPool.hpp	/^            ThreadPool(size_t threadNum, size_t queueMaxSize): threads_(threadNum), queue_(queueMaxSize)\/\/, mutex_(), isEmpty__(mutex_)$/;"	f	class:Limonp::ThreadPool
ThreadPool	include/CppJieba/Limonp/ThreadPool.hpp	/^    class ThreadPool: NonCopyable$/;"	c	namespace:Limonp
ThreadPool	include/ThreadPool.h	/^class ThreadPool:public Uncopyable{$/;"	c
ThreadPool	src/ThreadPool.cpp	/^ThreadPool::ThreadPool(const _TYPE_VECSIZE& vec_size):_thread_vec(vec_size)$/;"	f	class:ThreadPool
Token	include/json/reader.h	/^      class Token$/;"	c	class:Json::Reader
TokenType	include/json/reader.h	/^      enum TokenType$/;"	g	class:Json::Reader
TransCode	include/CppJieba/TransCode.hpp	/^    namespace TransCode$/;"	n	namespace:CppJieba
Trie	include/CppJieba/Trie.hpp	/^                Trie(const KeysContainerType& keys, const ValueContainerType& valuePointers)$/;"	f	class:CppJieba::Trie
Trie	include/CppJieba/Trie.hpp	/^        class Trie$/;"	c	namespace:CppJieba
TrieNode	include/CppJieba/Trie.hpp	/^        class TrieNode$/;"	c	namespace:CppJieba
TrieNodeType	include/CppJieba/Trie.hpp	/^                typedef TrieNode<KeyType, ValueType> TrieNodeType;$/;"	t	class:CppJieba::Trie
TrieType	include/CppJieba/DictTrie.hpp	/^            typedef Trie<Unicode::value_type, DictUnit, Unicode, vector<Unicode>, vector<const DictUnit*> > TrieType;$/;"	t	class:CppJieba::DictTrie
UINT2	include/CppJieba/Limonp/Md5.hpp	/^typedef unsigned short int UINT2;$/;"	t	namespace:Limonp
UINT4	include/CppJieba/Limonp/Md5.hpp	/^typedef unsigned int UINT4;$/;"	t	namespace:Limonp
UInt	include/json/forwards.h	/^   typedef unsigned int UInt;$/;"	t	namespace:Json
UInt	include/json/value.h	/^      typedef Json::UInt UInt;$/;"	t	class:Json::Value
UNKNOWN_TAG	include/CppJieba/DictTrie.hpp	/^    const char* const UNKNOWN_TAG = "x";$/;"	m	namespace:CppJieba
Uncopyable	include/Uncopyable.h	/^    Uncopyable(){}$/;"	f	class:Uncopyable
Uncopyable	include/Uncopyable.h	/^class Uncopyable{$/;"	c
Unicode	include/CppJieba/TransCode.hpp	/^    typedef Limonp::LocalVector<UnicodeValueType> Unicode;$/;"	t	namespace:CppJieba
UnicodeValueType	include/CppJieba/TransCode.hpp	/^    typedef uint16_t UnicodeValueType;$/;"	t	namespace:CppJieba
Update	include/CppJieba/Limonp/Md5.hpp	/^  void Update($/;"	f	class:Limonp::MD5
Value	include/json/value.h	/^   class JSON_API Value $/;"	c	namespace:Json
ValueAllocator	include/json/value.h	/^   class ValueAllocator$/;"	c	namespace:Json
ValueArrayAllocator	include/json/value.h	/^   class JSON_API ValueArrayAllocator$/;"	c	namespace:Json
ValueConstIterator	include/json/value.h	/^   class ValueConstIterator : public ValueIteratorBase$/;"	c	namespace:Json
ValueHolder	include/json/value.h	/^      union ValueHolder$/;"	u	class:Json::Value
ValueInternalArray	include/json/value.h	/^   class JSON_API ValueInternalArray$/;"	c	namespace:Json
ValueInternalLink	include/json/value.h	/^   class JSON_API ValueInternalLink$/;"	c	namespace:Json
ValueInternalMap	include/json/value.h	/^   class JSON_API ValueInternalMap$/;"	c	namespace:Json
ValueIterator	include/json/value.h	/^   class ValueIterator : public ValueIteratorBase$/;"	c	namespace:Json
ValueIteratorBase	include/json/value.h	/^   class ValueIteratorBase$/;"	c	namespace:Json
ValueMapAllocator	include/json/value.h	/^   class JSON_API ValueMapAllocator$/;"	c	namespace:Json
ValueType	include/json/value.h	/^   enum ValueType$/;"	g	namespace:Json
WorkThread	include/WorkThread.h	/^class WorkThread:public Thread{$/;"	c
Worker	include/CppJieba/Limonp/ThreadPool.hpp	/^                    Worker(ThreadPool* pool): ptThreadPool_(pool)$/;"	f	class:Limonp::ThreadPool::Worker
Worker	include/CppJieba/Limonp/ThreadPool.hpp	/^            class Worker: public IThread$/;"	c	class:Limonp::ThreadPool
Writer	include/json/writer.h	/^   class JSON_API Writer$/;"	c	namespace:Json
_CLEAN_GBK_TOKEN_H_	include/CleanGBKToken.hpp	2;"	d
_CONFIGURE_H_	include/Configure.h	10;"	d
_CSTR_BUFFER_SIZE	include/Log.hpp	/^static const int _CSTR_BUFFER_SIZE = 32;$/;"	m	namespace:ABQ
_DICTION_H_	include/Diction.h	8;"	d
_DICT_VEC_TYPE	include/Diction.h	/^    typedef std::vector<std::pair<std::string,size_t> > _DICT_VEC_TYPE;$/;"	t	class:Diction
_EDIT_DISTANCE_H_	include/edit_distance.h	8;"	d
_ENCODING_CONVERTER_H_	include/EncodingConverter.hpp	3;"	d
_ILEAGAL	include/edit_distance.h	18;"	d
_ILEAGAL	include/string_tools.h	13;"	d
_INDEX_H_	include/Index.h	8;"	d
_INDEX_MAP_TYPE	include/Index.h	/^    typedef std::unordered_map<std::string,std::set<size_t> > _INDEX_MAP_TYPE;$/;"	t	class:Index
_IS_ASCIII	include/edit_distance.h	19;"	d
_IS_ASCIII	include/string_tools.h	15;"	d
_IS_GBK	include/edit_distance.h	20;"	d
_IS_GBK	include/string_tools.h	16;"	d
_IS_NULL	include/string_tools.h	14;"	d
_IS_UTF8	include/edit_distance.h	21;"	d
_IS_UTF8	include/string_tools.h	17;"	d
_LEVEL_DEBUG	include/Log.hpp	/^static const int _LEVEL_DEBUG = 0;$/;"	m	namespace:ABQ
_LEVEL_ERROR	include/Log.hpp	/^static const int _LEVEL_ERROR = 3;$/;"	m	namespace:ABQ
_LEVEL_FATAL	include/Log.hpp	/^static const int _LEVEL_FATAL = 4;$/;"	m	namespace:ABQ
_LEVEL_INFO	include/Log.hpp	/^static const int _LEVEL_INFO = 1;$/;"	m	namespace:ABQ
_LEVEL_WARN	include/Log.hpp	/^static const int _LEVEL_WARN = 2;$/;"	m	namespace:ABQ
_LOG_FORMAT	include/Log.hpp	/^static const char * _LOG_FORMAT = "%s %s:%d %s %s\\n";$/;"	m	namespace:ABQ
_LOG_LEVEL_ARRAY	include/Log.hpp	/^static const char * _LOG_LEVEL_ARRAY[5] = {"DEBUG","INFO","WARN","ERROR","FATAL"};$/;"	m	namespace:ABQ
_LOG_TIME_FORMAT	include/Log.hpp	/^static const char * _LOG_TIME_FORMAT = "%Y-%m-%d %H:%M:%S"; $/;"	m	namespace:ABQ
_LogDebug	include/Log.hpp	22;"	d
_LogError	include/Log.hpp	28;"	d
_LogFatal	include/Log.hpp	30;"	d
_LogInfo	include/Log.hpp	24;"	d
_LogWarn	include/Log.hpp	26;"	d
_MAXWELL_CONDITION_H_	include/Condition.h	12;"	d
_MAXWELL_LOG_H_	include/Log.hpp	2;"	d
_MAXWELL_MUTEXLOCK_H_	include/Lock.h	10;"	d
_MAXWELL_TASK_H_	include/Task.h	8;"	d
_MAXWELL_THREADPOOL_H_	include/ThreadPool.h	9;"	d
_MAXWELL_THREAD_H_	include/Thread.h	8;"	d
_MAXWELL_UNCOPYABLE_H_	include/Uncopyable.h	9;"	d
_MAXWELL_WORKTHREAD_H_	include/WorkThread.h	8;"	d
_QUERY_H_	include/Query.h	8;"	d
_READLOCK	include/Lock.h	/^    enum{_READLOCK = 0,_WRITELOCK = 1};$/;"	e	enum:LockBase::__anon7
_RESULT_VEC_TYPE	include/Query.h	/^    typedef std::vector<std::pair<std::string,int> > _RESULT_VEC_TYPE;$/;"	t	class:Query
_STRING_TOOL_H_	include/string_tools.h	3;"	d
_TYPE_VECSIZE	include/ThreadPool.h	/^    typedef std::vector<WorkThread>::size_type _TYPE_VECSIZE;$/;"	t	class:ThreadPool
_WRITELOCK	include/Lock.h	/^    enum{_READLOCK = 0,_WRITELOCK = 1};$/;"	e	enum:LockBase::__anon7
__MD5_H__	include/CppJieba/Limonp/Md5.hpp	2;"	d
__context_t	include/CppJieba/Limonp/Md5.hpp	/^  struct __context_t {$/;"	s	class:Limonp::MD5
_calcDP	include/CppJieba/MPSegment.hpp	/^            void _calcDP(vector<SegmentChar>& SegmentChars) const$/;"	f	class:CppJieba::MPSegment
_calculateWeight	include/CppJieba/DictTrie.hpp	/^            void _calculateWeight(vector<DictUnit>& nodeInfos) const$/;"	f	class:CppJieba::DictTrie
_cmp	include/CppJieba/KeywordExtractor.hpp	/^            static bool _cmp(const pair<string, double>& lhs, const pair<string, double>& rhs)$/;"	f	class:CppJieba::KeywordExtractor
_cond_lock	include/Condition.h	/^    MutexLock& _cond_lock;$/;"	m	class:Condition
_condition	include/Condition.h	/^    pthread_cond_t _condition;   $/;"	m	class:Condition
_condition	include/ThreadPool.h	/^    Condition _condition;$/;"	m	class:ThreadPool
_conf_map	include/Configure.h	/^    std::map<std::string,std::string> _conf_map;$/;"	m	class:Configure
_creatTrie	include/CppJieba/DictTrie.hpp	/^            TrieType * _creatTrie(const vector<DictUnit>& dictUnits)$/;"	f	class:CppJieba::DictTrie
_createTrie	include/CppJieba/Trie.hpp	/^                void _createTrie(const KeysContainerType& keys, const ValueContainerType& valuePointers)$/;"	f	class:CppJieba::Trie
_cut	include/CppJieba/HMMSegment.hpp	/^            bool _cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<Unicode>& res) const $/;"	f	class:CppJieba::HMMSegment
_cut	include/CppJieba/MPSegment.hpp	/^            bool _cut(const vector<SegmentChar>& segmentChars, vector<Unicode>& res)const$/;"	f	class:CppJieba::MPSegment
_deleteNode	include/CppJieba/Trie.hpp	/^                void _deleteNode(TrieNodeType* node)$/;"	f	class:CppJieba::Trie
_dictTrie	include/CppJieba/FullSegment.hpp	/^            const DictTrie* _dictTrie;$/;"	m	class:CppJieba::FullSegment
_dictTrie	include/CppJieba/MPSegment.hpp	/^            DictTrie _dictTrie;$/;"	m	class:CppJieba::MPSegment
_dictTrie	include/CppJieba/PosTagger.hpp	/^            DictTrie _dictTrie;$/;"	m	class:CppJieba::PosTagger
_dict_vec	include/Diction.h	/^    _DICT_VEC_TYPE _dict_vec;$/;"	m	class:Diction
_distance	include/Query.h	/^    int _distance;$/;"	m	class:HeapData4Query
_emitProbB	include/CppJieba/HMMSegment.hpp	/^            EmitProbMap _emitProbB;$/;"	m	class:CppJieba::HMMSegment
_emitProbE	include/CppJieba/HMMSegment.hpp	/^            EmitProbMap _emitProbE;$/;"	m	class:CppJieba::HMMSegment
_emitProbM	include/CppJieba/HMMSegment.hpp	/^            EmitProbMap _emitProbM;$/;"	m	class:CppJieba::HMMSegment
_emitProbS	include/CppJieba/HMMSegment.hpp	/^            EmitProbMap _emitProbS;$/;"	m	class:CppJieba::HMMSegment
_emitProbVec	include/CppJieba/HMMSegment.hpp	/^            vector<EmitProbMap* > _emitProbVec;$/;"	m	class:CppJieba::HMMSegment
_exclude_set	src/DictionBuilder.cpp	/^set<string> _exclude_set;$/;"	v
_findMaxWeight	include/CppJieba/DictTrie.hpp	/^            double _findMaxWeight(const vector<DictUnit>& nodeInfos) const$/;"	f	class:CppJieba::DictTrie
_findMinWeight	include/CppJieba/DictTrie.hpp	/^            double _findMinWeight(const vector<DictUnit>& nodeInfos) const$/;"	f	class:CppJieba::DictTrie
_fullSeg	include/CppJieba/QuerySegment.hpp	/^        FullSegment _fullSeg;$/;"	m	class:CppJieba::QuerySegment
_getEmitProb	include/CppJieba/HMMSegment.hpp	/^            double _getEmitProb(const EmitProbMap* ptMp, uint16_t key, double defVal)const $/;"	f	class:CppJieba::HMMSegment
_getLine	include/CppJieba/HMMSegment.hpp	/^            bool _getLine(ifstream& ifile, string& line)$/;"	f	class:CppJieba::HMMSegment
_hmmSeg	include/CppJieba/MixSegment.hpp	/^            HMMSegment _hmmSeg;$/;"	m	class:CppJieba::MixSegment
_home_path	include/Configure.h	/^    std::string _home_path;$/;"	m	class:Configure
_idfAverage	include/CppJieba/KeywordExtractor.hpp	/^            double _idfAverage;$/;"	m	class:CppJieba::KeywordExtractor
_idfMap	include/CppJieba/KeywordExtractor.hpp	/^            unordered_map<string, double> _idfMap;$/;"	m	class:CppJieba::KeywordExtractor
_index	include/Query.h	/^    int _index;$/;"	m	class:HeapData4Query
_index_hashmap	include/Index.h	/^    _INDEX_MAP_TYPE _index_hashmap;$/;"	m	class:Index
_insertNode	include/CppJieba/Trie.hpp	/^                void _insertNode(const KeyContainerType& key, const ValueType* ptValue)$/;"	f	class:CppJieba::Trie
_isBorrowed	include/CppJieba/FullSegment.hpp	/^            bool _isBorrowed;$/;"	m	class:CppJieba::FullSegment
_isSingleWord	include/CppJieba/KeywordExtractor.hpp	/^            bool _isSingleWord(const string& str) const$/;"	f	class:CppJieba::KeywordExtractor
_is_pool_open	include/ThreadPool.h	/^    bool _is_pool_open;$/;"	m	class:ThreadPool
_lo	include/Task.h	/^    int _lo;    \/\/ 返回的时候用于存放结果$/;"	m	class:Task
_loadConfigFile	src/Configure.cpp	/^bool Configure::_loadConfigFile(const string& filename){$/;"	f	class:Configure
_loadDict	include/CppJieba/DictTrie.hpp	/^            void _loadDict(const string& filePath, vector<DictUnit>& nodeInfos) const$/;"	f	class:CppJieba::DictTrie
_loadEmitProb	include/CppJieba/HMMSegment.hpp	/^            bool _loadEmitProb(const string& line, EmitProbMap& mp)$/;"	f	class:CppJieba::HMMSegment
_loadIdfDict	include/CppJieba/KeywordExtractor.hpp	/^            void _loadIdfDict(const string& idfPath)$/;"	f	class:CppJieba::KeywordExtractor
_loadModel	include/CppJieba/HMMSegment.hpp	/^            bool _loadModel(const char* const filePath)$/;"	f	class:CppJieba::HMMSegment
_loadSpecialSymbols	include/CppJieba/SegmentBase.hpp	/^            void _loadSpecialSymbols()$/;"	f	class:CppJieba::SegmentBase
_loadStopWordDict	include/CppJieba/KeywordExtractor.hpp	/^            void _loadStopWordDict(const string& filePath)$/;"	f	class:CppJieba::KeywordExtractor
_loadUserDict	include/CppJieba/DictTrie.hpp	/^            void _loadUserDict(const string& filePath, double defaultWeight, const string& defaultTag)$/;"	f	class:CppJieba::DictTrie
_lock	include/Lock.h	/^    LockBase& _lock;$/;"	m	class:LockSafeGuard
_maxWordLen	include/CppJieba/QuerySegment.hpp	/^        size_t _maxWordLen;$/;"	m	class:CppJieba::QuerySegment
_minWeight	include/CppJieba/DictTrie.hpp	/^            double _minWeight;$/;"	m	class:CppJieba::DictTrie
_mixSeg	include/CppJieba/QuerySegment.hpp	/^        MixSegment _mixSeg;$/;"	m	class:CppJieba::QuerySegment
_mpSeg	include/CppJieba/MixSegment.hpp	/^            MPSegment _mpSeg;$/;"	m	class:CppJieba::MixSegment
_mutex	include/Lock.h	/^    pthread_mutex_t _mutex;$/;"	m	class:MutexLock
_mutex_lock	include/ThreadPool.h	/^    MutexLock _mutex_lock;$/;"	m	class:ThreadPool
_nodeInfos	include/CppJieba/DictTrie.hpp	/^            vector<DictUnit> _nodeInfos;$/;"	m	class:CppJieba::DictTrie
_p_conf_instance	include/Configure.h	/^    static Configure* _p_conf_instance;$/;"	m	class:Configure
_p_lock	include/Configure.h	/^    static LockBase* _p_lock;$/;"	m	class:Configure
_p_lock	include/Diction.h	/^    static MutexLock* _p_lock;$/;"	m	class:Diction
_p_lock	src/Configure.cpp	/^LockBase* Configure::_p_lock = new RWLock();$/;"	m	class:Configure	file:
_p_lock	src/Diction.cpp	/^MutexLock* Diction::_p_lock = new MutexLock();$/;"	m	class:Diction	file:
_p_pool	include/WorkThread.h	/^    ThreadPool* _p_pool; $/;"	m	class:WorkThread
_ro	include/Task.h	/^    int _ro;   \/\/virtual void execute(void*)  = 0;$/;"	m	class:Task
_root	include/CppJieba/Trie.hpp	/^                TrieNodeType* _root;$/;"	m	class:CppJieba::Trie
_rw_lock	include/Lock.h	/^    pthread_rwlock_t _rw_lock;$/;"	m	class:RWLock
_s_p_instance	include/Diction.h	/^    static Diction* _s_p_instance;$/;"	m	class:Diction
_s_p_instance	include/Index.h	/^    static Index* _s_p_instance;$/;"	m	class:Index
_s_p_lock	include/Index.h	/^    static MutexLock* _s_p_lock;$/;"	m	class:Index
_s_p_lock	src/Index.cpp	/^MutexLock* Index::_s_p_lock = new MutexLock();$/;"	m	class:Index	file:
_segment	include/CppJieba/KeywordExtractor.hpp	/^            MixSegment _segment;$/;"	m	class:CppJieba::KeywordExtractor
_segment	include/CppJieba/PosTagger.hpp	/^            MixSegment _segment;$/;"	m	class:CppJieba::PosTagger
_shrink	include/CppJieba/DictTrie.hpp	/^            void _shrink(vector<DictUnit>& units) const$/;"	f	class:CppJieba::DictTrie
_sock_fd	include/Task.h	/^    int _sock_fd; \/\/用于存放 sock_file_descripter$/;"	m	class:Task
_specialSymbols	include/CppJieba/SegmentBase.hpp	/^            unordered_set<UnicodeValueType> _specialSymbols;$/;"	m	class:CppJieba::SegmentBase
_startProb	include/CppJieba/HMMSegment.hpp	/^            double _startProb[STATUS_SUM];$/;"	m	class:CppJieba::HMMSegment
_statMap	include/CppJieba/HMMSegment.hpp	/^            char _statMap[STATUS_SUM];$/;"	m	class:CppJieba::HMMSegment
_stopWords	include/CppJieba/KeywordExtractor.hpp	/^            unordered_set<string> _stopWords;$/;"	m	class:CppJieba::KeywordExtractor
_task_queue	include/ThreadPool.h	/^    std::queue<Task> _task_queue;$/;"	m	class:ThreadPool
_thread_vec	include/ThreadPool.h	/^    std::vector<WorkThread> _thread_vec;$/;"	m	class:ThreadPool
_tid	include/Thread.h	/^    pthread_t _tid;$/;"	m	class:Thread
_transProb	include/CppJieba/HMMSegment.hpp	/^            double _transProb[STATUS_SUM][STATUS_SUM];$/;"	m	class:CppJieba::HMMSegment
_trie	include/CppJieba/DictTrie.hpp	/^            TrieType * _trie;$/;"	m	class:CppJieba::DictTrie
_userDictSingleChineseWord	include/CppJieba/DictTrie.hpp	/^            unordered_set<Unicode::value_type> _userDictSingleChineseWord;$/;"	m	class:CppJieba::DictTrie
_viterbi	include/CppJieba/HMMSegment.hpp	/^            bool _viterbi(Unicode::const_iterator begin, Unicode::const_iterator end, vector<size_t>& status)const$/;"	f	class:CppJieba::HMMSegment
add	include/CppJieba/Limonp/ThreadPool.hpp	/^            void add(ITask* task)$/;"	f	class:Limonp::ThreadPool
addChildValues_	include/json/writer.h	/^      bool addChildValues_;$/;"	m	class:Json::StyledStreamWriter
addChildValues_	include/json/writer.h	/^      bool addChildValues_;$/;"	m	class:Json::StyledWriter
addTask	src/ThreadPool.cpp	/^bool ThreadPool::addTask(Task t){$/;"	f	class:ThreadPool
allowComments_	include/json/features.h	/^      bool allowComments_;$/;"	m	class:Json::Features
args_	include/CppJieba/Limonp/ArgvContext.hpp	/^            vector<string> args_;$/;"	m	class:Limonp::ArgvContext
args_	include/json/value.h	/^      Args args_;$/;"	m	class:Json::Path
arrayValue	include/json/value.h	/^      arrayValue,    \/\/\/< array value (ordered list)$/;"	e	enum:Json::ValueType
array_	include/json/value.h	/^         ValueInternalArray *array_;$/;"	m	struct:Json::ValueInternalArray::IteratorState
array_	include/json/value.h	/^         ValueInternalArray *array_;$/;"	m	union:Json::Value::ValueHolder
array_	include/json/value.h	/^         ValueInternalArray::IteratorState array_;$/;"	m	union:Json::ValueIteratorBase::__anon6
begin	include/CppJieba/Limonp/LocalVector.hpp	/^                const_iterator begin() const$/;"	f	class:Limonp::LocalVector
begin_	include/json/reader.h	/^      Location begin_;$/;"	m	class:Json::Reader
bool_	include/json/value.h	/^         bool bool_;$/;"	m	union:Json::Value::ValueHolder
booleanValue	include/json/value.h	/^      booleanValue,  \/\/\/< bool value$/;"	e	enum:Json::ValueType
bow	debug/condition_test.cpp	/^static queue<int> bow;$/;"	v	file:
bucketIndex_	include/json/value.h	/^         BucketIndex bucketIndex_;$/;"	m	struct:Json::ValueInternalMap::IteratorState
bucketsSize_	include/json/value.h	/^      BucketIndex bucketsSize_;$/;"	m	class:Json::ValueInternalMap
buckets_	include/json/value.h	/^      ValueInternalLink *buckets_;$/;"	m	class:Json::ValueInternalMap
buffer	include/CppJieba/Limonp/Md5.hpp	/^    unsigned char buffer[64];                         \/* input buffer *\/$/;"	m	struct:Limonp::MD5::__context_t
buffer_	include/CppJieba/Limonp/LocalVector.hpp	/^                T buffer_[LOCAL_VECTOR_BUFFER_SIZE];$/;"	m	class:Limonp::LocalVector
buildExcludeSet	src/DictionBuilder.cpp	/^void buildExcludeSet(){$/;"	f
c_str	include/json/value.h	/^      const char *c_str() const$/;"	f	class:Json::StaticString
capacity	include/CppJieba/Limonp/BlockingQueue.hpp	/^                size_t capacity() const$/;"	f	class:Limonp::BoundedBlockingQueue
capacity	include/CppJieba/Limonp/BoundedQueue.hpp	/^                size_t capacity() const$/;"	f	class:Limonp::BoundedQueue
capacity	include/CppJieba/Limonp/LocalVector.hpp	/^                size_t capacity() const$/;"	f	class:Limonp::LocalVector
capacity_	include/CppJieba/Limonp/BoundedQueue.hpp	/^                const size_t capacity_;$/;"	m	class:Limonp::BoundedQueue
capacity_	include/CppJieba/Limonp/LocalVector.hpp	/^                size_t capacity_;$/;"	m	class:Limonp::LocalVector
charset_	include/CppJieba/Limonp/MysqlClient.hpp	/^            const string charset_;$/;"	m	class:Limonp::MysqlClient
childValues_	include/json/writer.h	/^      ChildValues childValues_;$/;"	m	class:Json::StyledStreamWriter
childValues_	include/json/writer.h	/^      ChildValues childValues_;$/;"	m	class:Json::StyledWriter
circular__buffer	include/CppJieba/Limonp/BoundedQueue.hpp	/^                vector<T> circular__buffer;$/;"	m	class:Limonp::BoundedQueue
cleanGBKToken	include/CleanGBKToken.hpp	/^void cleanGBKToken(std::string& in){$/;"	f
clear	include/CppJieba/Limonp/BoundedQueue.hpp	/^                void clear()$/;"	f	class:Limonp::BoundedQueue
clear	include/CppJieba/Limonp/LocalVector.hpp	/^                void clear()$/;"	f	class:Limonp::LocalVector
closePool	src/ThreadPool.cpp	/^void ThreadPool::closePool(){$/;"	f	class:ThreadPool
code_convert	include/CppJieba/Limonp/CodeConverter.hpp	/^    inline bool code_convert(const char* from_charset, const char* to_charset, const string& from, string& to)$/;"	f	namespace:Limonp
code_convert	include/EncodingConverter.hpp	/^int code_convert(char *from_charset,char *to_charset,char *inbuf,size_t inlen,char *outbuf,size_t outlen)$/;"	f
collectComments_	include/json/reader.h	/^      bool collectComments_;$/;"	m	class:Json::Reader
commentAfter	include/json/value.h	/^      commentAfter,             \/\/\/< a comment on the line after a value (only make sense for root value)$/;"	e	enum:Json::CommentPlacement
commentAfterOnSameLine	include/json/value.h	/^      commentAfterOnSameLine,   \/\/\/< a comment just after a value on the same line$/;"	e	enum:Json::CommentPlacement
commentBefore	include/json/value.h	/^      commentBefore = 0,        \/\/\/< a comment placed on the line before a value$/;"	e	enum:Json::CommentPlacement
comment_	include/json/value.h	/^         char *comment_;$/;"	m	struct:Json::Value::CommentInfo
commentsBefore_	include/json/reader.h	/^      std::string commentsBefore_;$/;"	m	class:Json::Reader
comments_	include/json/value.h	/^      CommentInfo *comments_;$/;"	m	class:Json::Value
conn_	include/CppJieba/Limonp/MysqlClient.hpp	/^            MYSQL * conn_;$/;"	m	class:Limonp::MysqlClient
const_iterator	include/CppJieba/Limonp/LocalVector.hpp	/^                typedef const T* const_iterator ;$/;"	t	class:Limonp::LocalVector
const_iterator	include/json/value.h	/^      typedef ValueConstIterator const_iterator;$/;"	t	class:Json::Value
consumer_thread_func	debug/condition_test.cpp	/^void *consumer_thread_func(void *arg){$/;"	f
context	include/CppJieba/Limonp/Md5.hpp	/^  } context ;$/;"	m	class:Limonp::MD5	typeref:struct:Limonp::MD5::__context_t
convert	include/CppJieba/Limonp/CodeConverter.hpp	/^            bool convert(const string& from, string& to) const$/;"	f	class:Limonp::CodeConverter
count	include/CppJieba/Limonp/Md5.hpp	/^    UINT4 count[2];        \/* number of bits, modulo 2^64 (lsb first) *\/$/;"	m	struct:Limonp::MD5::__context_t
cstr_	include/json/value.h	/^         const char *cstr_;$/;"	m	class:Json::Value::CZString
currentItemIndex_	include/json/value.h	/^         unsigned int currentItemIndex_;$/;"	m	struct:Json::ValueInternalArray::IteratorState
currentPageIndex_	include/json/value.h	/^         Value **currentPageIndex_;$/;"	m	struct:Json::ValueInternalArray::IteratorState
current_	include/json/reader.h	/^      Location current_;$/;"	m	class:Json::Reader
current_	include/json/value.h	/^      Value::ObjectValues::iterator current_;$/;"	m	class:Json::ValueIteratorBase
cut	include/CppJieba/FullSegment.hpp	/^            bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<Unicode>& res) const$/;"	f	class:CppJieba::FullSegment
cut	include/CppJieba/FullSegment.hpp	/^            bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<string>& res) const$/;"	f	class:CppJieba::FullSegment
cut	include/CppJieba/HMMSegment.hpp	/^            bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<Unicode>& res)const $/;"	f	class:CppJieba::HMMSegment
cut	include/CppJieba/HMMSegment.hpp	/^            virtual bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<string>& res)const$/;"	f	class:CppJieba::HMMSegment
cut	include/CppJieba/MPSegment.hpp	/^            bool cut(Unicode::const_iterator begin , Unicode::const_iterator end, vector<Unicode>& res) const$/;"	f	class:CppJieba::MPSegment
cut	include/CppJieba/MPSegment.hpp	/^            virtual bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<string>& res)const$/;"	f	class:CppJieba::MPSegment
cut	include/CppJieba/MixSegment.hpp	/^            virtual bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<Unicode>& res) const$/;"	f	class:CppJieba::MixSegment
cut	include/CppJieba/MixSegment.hpp	/^            virtual bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<string>& res)const$/;"	f	class:CppJieba::MixSegment
cut	include/CppJieba/QuerySegment.hpp	/^        bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<Unicode>& res) const$/;"	f	class:CppJieba::QuerySegment
cut	include/CppJieba/QuerySegment.hpp	/^        bool cut(Unicode::const_iterator begin, Unicode::const_iterator end, vector<string>& res) const$/;"	f	class:CppJieba::QuerySegment
cut	include/CppJieba/SegmentBase.hpp	/^            virtual bool cut(const string& str, vector<string>& res) const$/;"	f	class:CppJieba::SegmentBase
dag	include/CppJieba/MPSegment.hpp	/^        DagType dag;$/;"	m	struct:CppJieba::SegmentChar
db_	include/CppJieba/Limonp/MysqlClient.hpp	/^            const string db_;$/;"	m	class:Limonp::MysqlClient
decode	include/CppJieba/TransCode.hpp	/^        inline bool decode(const string& str, Unicode& res)$/;"	f	namespace:CppJieba::TransCode
difference_type	include/json/value.h	/^      typedef int difference_type;$/;"	t	class:Json::ValueConstIterator
difference_type	include/json/value.h	/^      typedef int difference_type;$/;"	t	class:Json::ValueIterator
difference_type	include/json/value.h	/^      typedef int difference_type;$/;"	t	class:Json::ValueIteratorBase
digestChars	include/CppJieba/Limonp/Md5.hpp	/^  char digestChars[ 33 ] ;$/;"	m	class:Limonp::MD5
digestFile	include/CppJieba/Limonp/Md5.hpp	/^  const char* digestFile( const char *filename )$/;"	f	class:Limonp::MD5
digestMemory	include/CppJieba/Limonp/Md5.hpp	/^  const char* digestMemory( BYTE *memchunk, int len )$/;"	f	class:Limonp::MD5
digestRaw	include/CppJieba/Limonp/Md5.hpp	/^  BYTE digestRaw[ 16 ] ;$/;"	m	class:Limonp::MD5
digestString	include/CppJieba/Limonp/Md5.hpp	/^  const char* digestString(const char *string )$/;"	f	class:Limonp::MD5
document_	include/json/reader.h	/^      std::string document_;$/;"	m	class:Json::Reader
document_	include/json/writer.h	/^      std::ostream* document_;$/;"	m	class:Json::StyledStreamWriter
document_	include/json/writer.h	/^      std::string document_;$/;"	m	class:Json::FastWriter
document_	include/json/writer.h	/^      std::string document_;$/;"	m	class:Json::StyledWriter
duplicate	include/json/value.h	/^            duplicate,$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
duplicateOnCopy	include/json/value.h	/^            duplicateOnCopy$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
editDistance	include/edit_distance.h	/^int editDistance(std::vector<uint32_t>& sa,std::vector<uint32_t>& sb){$/;"	f
empty	include/CppJieba/Limonp/BlockingQueue.hpp	/^                bool empty() const$/;"	f	class:Limonp::BlockingQueue
empty	include/CppJieba/Limonp/BlockingQueue.hpp	/^                bool empty() const$/;"	f	class:Limonp::BoundedBlockingQueue
empty	include/CppJieba/Limonp/BoundedQueue.hpp	/^                bool empty() const$/;"	f	class:Limonp::BoundedQueue
empty	include/CppJieba/Limonp/LocalVector.hpp	/^                bool empty() const$/;"	f	class:Limonp::LocalVector
encode	include/CppJieba/TransCode.hpp	/^        inline bool encode(Unicode::const_iterator begin, Unicode::const_iterator end, string& res)$/;"	f	namespace:CppJieba::TransCode
encode	include/CppJieba/TransCode.hpp	/^        inline bool encode(const Unicode& uni, string& res)$/;"	f	namespace:CppJieba::TransCode
end	include/CppJieba/Limonp/LocalVector.hpp	/^                const_iterator end() const$/;"	f	class:Limonp::LocalVector
end_	include/json/reader.h	/^         Location end_;$/;"	m	class:Json::Reader::Token
end_	include/json/reader.h	/^      Location end_;$/;"	m	class:Json::Reader
endsWith	include/CppJieba/Limonp/StringUtil.hpp	/^    inline bool endsWith(const string& str, const string& suffix)$/;"	f	namespace:Limonp
errors_	include/json/reader.h	/^      Errors errors_;$/;"	m	class:Json::Reader
excute	src/fork_server.cpp	/^void excute(int fd,ThreadPool& pool){$/;"	f
excuteError	include/Condition.h	/^    void excuteError(){$/;"	f	class:Condition
excuteError	include/Lock.h	/^    void excuteError(){$/;"	f	class:MutexLock
excuteError	include/Lock.h	/^    void excuteError(){$/;"	f	class:RWLock
excuteTask	src/WorkThread.cpp	/^void excuteTask(Task &t){$/;"	f
executeSql	include/CppJieba/Limonp/MysqlClient.hpp	/^            bool executeSql(const string& sql)$/;"	f	class:Limonp::MysqlClient
exit	src/Thread.cpp	/^void Thread::exit(){$/;"	f	class:Thread
exponent_16	include/CppJieba/Limonp/CastFloat.hpp	/^        static const short exponent_16 = (short)0x3C00;$/;"	m	namespace:Limonp::CastFloat
exponent_32	include/CppJieba/Limonp/CastFloat.hpp	/^        static const int exponent_32 = 0x07800000;$/;"	m	namespace:Limonp::CastFloat
exponent_fill_32	include/CppJieba/Limonp/CastFloat.hpp	/^        static const int exponent_fill_32 = 0x38000000;$/;"	m	namespace:Limonp::CastFloat
extra_	include/json/reader.h	/^         Location extra_;$/;"	m	class:Json::Reader::ErrorInfo
extract	include/CppJieba/KeywordExtractor.hpp	/^            bool extract(const string& str, vector<pair<string, double> >& keywords, size_t topN) const$/;"	f	class:CppJieba::KeywordExtractor
extract	include/CppJieba/KeywordExtractor.hpp	/^            bool extract(const string& str, vector<string>& keywords, size_t topN) const$/;"	f	class:CppJieba::KeywordExtractor
features_	include/json/reader.h	/^      Features features_;$/;"	m	class:Json::Reader
find	include/CppJieba/DictTrie.hpp	/^            bool find(Unicode::const_iterator begin, Unicode::const_iterator end, DagType& dag, size_t offset = 0) const$/;"	f	class:CppJieba::DictTrie
find	include/CppJieba/DictTrie.hpp	/^            const DictUnit* find(Unicode::const_iterator begin, Unicode::const_iterator end) const$/;"	f	class:CppJieba::DictTrie
find	include/CppJieba/Trie.hpp	/^                bool find(typename KeyContainerType::const_iterator begin, typename KeyContainerType::const_iterator end, map<typename KeyContainerType::size_type, const ValueType* >& ordererMap, size_t offset = 0) const$/;"	f	class:CppJieba::Trie
find	include/CppJieba/Trie.hpp	/^                const ValueType* find(typename KeyContainerType::const_iterator begin, typename KeyContainerType::const_iterator end) const$/;"	f	class:CppJieba::Trie
flagAvailable	include/json/value.h	/^         flagAvailable = 0,$/;"	e	enum:Json::ValueInternalLink::InternalFlags
flagUsed	include/json/value.h	/^         flagUsed = 1$/;"	e	enum:Json::ValueInternalLink::InternalFlags
floatToIntBits	include/CppJieba/Limonp/CastFloat.hpp	/^        inline int floatToIntBits(float f)$/;"	f	namespace:Limonp::CastFloat
floatToShortBits	include/CppJieba/Limonp/CastFloat.hpp	/^        inline short floatToShortBits(float f)$/;"	f	namespace:Limonp::CastFloat
full	include/CppJieba/Limonp/BlockingQueue.hpp	/^                bool full() const$/;"	f	class:Limonp::BoundedBlockingQueue
full	include/CppJieba/Limonp/BoundedQueue.hpp	/^                bool full() const$/;"	f	class:Limonp::BoundedQueue
func	debug/vsnprintf_test.cpp	/^void func(string& fmt,...){$/;"	f
gbkTrans	include/CppJieba/Limonp/StringUtil.hpp	/^    bool gbkTrans(Uint16ContainerConIter begin, Uint16ContainerConIter end, string& res)$/;"	f	namespace:Limonp
gbkTrans	include/CppJieba/Limonp/StringUtil.hpp	/^    bool gbkTrans(const char* const str, size_t len, Uint16Container& vec)$/;"	f	namespace:Limonp
gbkTrans	include/CppJieba/Limonp/StringUtil.hpp	/^    bool gbkTrans(const string& str, Uint16Container& vec)$/;"	f	namespace:Limonp
gbk_utf8	include/EncodingConverter.hpp	/^bool gbk_utf8(string instr,string& outstr)$/;"	f
get	include/CppJieba/Limonp/Config.hpp	/^            bool get(const string& key, int & value) const$/;"	f	class:Limonp::Config
get	include/CppJieba/Limonp/Config.hpp	/^            bool get(const string& key, string& value) const$/;"	f	class:Limonp::Config
getConfigByName	src/Configure.cpp	/^string Configure::getConfigByName(const string& key)const{$/;"	f	class:Configure
getConfigInfo	include/CppJieba/Limonp/Config.hpp	/^            string getConfigInfo() const$/;"	f	class:Limonp::Config
getDictTrie	include/CppJieba/MPSegment.hpp	/^            const DictTrie* getDictTrie() const $/;"	f	class:CppJieba::MPSegment
getDictTrie	include/CppJieba/MixSegment.hpp	/^            const DictTrie* getDictTrie() const $/;"	f	class:CppJieba::MixSegment
getDictionVec	src/Diction.cpp	/^Diction::_DICT_VEC_TYPE& Diction::getDictionVec(){$/;"	f	class:Diction
getEditDistance	include/edit_distance.h	/^int getEditDistance(const std::string& candidite,const std::string& keyword){$/;"	f
getIndexMap	src/Index.cpp	/^Index::_INDEX_MAP_TYPE& Index::getIndexMap(){$/;"	f	class:Index
getIndexes	src/Index.cpp	/^bool Index::getIndexes(const std::string& keyword,std::set<size_t>& result_set){$/;"	f	class:Index
getInitFlag_	include/CppJieba/Limonp/InitOnOff.hpp	/^            bool getInitFlag_()const{return isInited_;};$/;"	f	class:Limonp::InitOnOff
getInstance	src/Configure.cpp	/^Configure* Configure::getInstance(){$/;"	f	class:Configure
getInstance	src/Diction.cpp	/^Diction* Diction::getInstance(){$/;"	f	class:Diction
getInstance	src/Index.cpp	/^Index* Index::getInstance(){$/;"	f	class:Index
getMin	include/edit_distance.h	/^uint32_t getMin(uint32_t a,uint32_t b,uint32_t c){$/;"	f
getMinWeight	include/CppJieba/DictTrie.hpp	/^            double getMinWeight() const {return _minWeight;};$/;"	f	class:CppJieba::DictTrie
getMutexPointer	include/Lock.h	/^    pthread_mutex_t* getMutexPointer(){$/;"	f	class:MutexLock
getPthreadMutex	include/CppJieba/Limonp/MutexLock.hpp	/^            pthread_mutex_t* getPthreadMutex()$/;"	f	class:Limonp::MutexLock
getSimWords	src/Query.cpp	/^void Query::getSimWords(const string& keyword,Query::_RESULT_VEC_TYPE& res_vec){$/;"	f	class:Query
getTask	src/ThreadPool.cpp	/^bool ThreadPool::getTask(Task *return_task){$/;"	f	class:ThreadPool
getThreadId	include/Thread.h	/^    pthread_t getThreadId()const{$/;"	f	class:Thread
getTime	include/CppJieba/Limonp/StringUtil.hpp	/^    inline void getTime(const string& format, string&  timeStr)$/;"	f	namespace:Limonp
get_character_code_type	include/edit_distance.h	/^int get_character_code_type(const char* s) $/;"	f
hasKey	include/CppJieba/Limonp/ArgvContext.hpp	/^            bool hasKey(const string& key) const$/;"	f	class:Limonp::ArgvContext
head_	include/CppJieba/Limonp/BoundedQueue.hpp	/^                size_t head_;$/;"	m	class:Limonp::BoundedQueue
host_	include/CppJieba/Limonp/MysqlClient.hpp	/^            const string host_;$/;"	m	class:Limonp::MysqlClient
iconv__handle	include/CppJieba/Limonp/CodeConverter.hpp	/^            iconv_t iconv__handle; $/;"	m	class:Limonp::CodeConverter
indentSize_	include/json/writer.h	/^      int indentSize_;$/;"	m	class:Json::StyledWriter
indentString_	include/json/writer.h	/^      std::string indentString_;$/;"	m	class:Json::StyledStreamWriter
indentString_	include/json/writer.h	/^      std::string indentString_;$/;"	m	class:Json::StyledWriter
indentation_	include/json/writer.h	/^      std::string indentation_;$/;"	m	class:Json::StyledStreamWriter
index_	include/json/value.h	/^         int index_;$/;"	m	class:Json::Value::CZString
index_	include/json/value.h	/^      UInt index_;$/;"	m	class:Json::PathArgument
index_map	src/IndexBuilder.cpp	/^MAP_TYPE index_map;$/;"	v
infinite_16	include/CppJieba/Limonp/CastFloat.hpp	/^        static const short infinite_16 = (short) 0x7FFF;$/;"	m	namespace:Limonp::CastFloat
infinitesmall_16	include/CppJieba/Limonp/CastFloat.hpp	/^        static const short infinitesmall_16 = (short) 0x0000;$/;"	m	namespace:Limonp::CastFloat
init	include/CppJieba/DictTrie.hpp	/^            bool init(const string& dictPath, const string& userDictPath = "")$/;"	f	class:CppJieba::DictTrie
init	include/CppJieba/FullSegment.hpp	/^            bool init(const DictTrie* dictTrie) $/;"	f	class:CppJieba::FullSegment
init	include/CppJieba/FullSegment.hpp	/^            bool init(const string& dictPath)$/;"	f	class:CppJieba::FullSegment
init	include/CppJieba/HMMSegment.hpp	/^            bool init(const string& filePath)$/;"	f	class:CppJieba::HMMSegment
init	include/CppJieba/KeywordExtractor.hpp	/^            bool init(const string& dictPath, const string& hmmFilePath, const string& idfPath, const string& stopWordPath)$/;"	f	class:CppJieba::KeywordExtractor
init	include/CppJieba/MPSegment.hpp	/^            bool init(const string& dictPath, const string& userDictPath = "")$/;"	f	class:CppJieba::MPSegment
init	include/CppJieba/MixSegment.hpp	/^            bool init(const string& mpSegDict, const string& hmmSegDict, const string& userDict = "")$/;"	f	class:CppJieba::MixSegment
init	include/CppJieba/PosTagger.hpp	/^            bool init(const string& dictPath, const string& hmmFilePath, const string& charStatus, const string& startProb, const string& emitProb, const string& endProb, const string& transProb)$/;"	f	class:CppJieba::PosTagger
init	include/CppJieba/QuerySegment.hpp	/^        bool init(const string& dict, const string& model, size_t maxWordLen)$/;"	f	class:CppJieba::QuerySegment
init_	include/CppJieba/Limonp/LocalVector.hpp	/^                void init_()$/;"	f	class:Limonp::LocalVector
init_	include/CppJieba/Limonp/MysqlClient.hpp	/^            bool init_()$/;"	f	class:Limonp::MysqlClient
insert	include/CppJieba/Limonp/MysqlClient.hpp	/^            size_t insert(const string& tableName, const string& keys, const vector<string>& vals)$/;"	f	class:Limonp::MysqlClient
intBitsToFloat	include/CppJieba/Limonp/CastFloat.hpp	/^        inline float intBitsToFloat(unsigned int x)$/;"	f	namespace:Limonp::CastFloat
intValue	include/json/value.h	/^      intValue,      \/\/\/< signed integer value$/;"	e	enum:Json::ValueType
int_	include/json/value.h	/^         Int int_;$/;"	m	union:Json::Value::ValueHolder
isArray_	include/json/value.h	/^      bool isArray_;$/;"	m	class:Json::ValueIteratorBase
isIn	include/CppJieba/Limonp/StdExtension.hpp	/^        bool isIn(const ContainType& contain, const KeyType& key)$/;"	f	namespace:std
isInStr	include/CppJieba/Limonp/StringUtil.hpp	/^    inline bool isInStr(const string& str, char ch)$/;"	f	namespace:Limonp
isInited_	include/CppJieba/Limonp/InitOnOff.hpp	/^            bool isInited_;$/;"	m	class:Limonp::InitOnOff
isItemAvailable	include/json/value.h	/^      inline bool isItemAvailable() const$/;"	f	class:Json::Value
isJoined	include/CppJieba/Limonp/Thread.hpp	/^            bool isJoined;$/;"	m	class:Limonp::IThread
isMemberNameStatic	include/json/value.h	/^      inline bool isMemberNameStatic() const$/;"	f	class:Json::Value
isNull_	include/json/value.h	/^      bool isNull_;$/;"	m	class:Json::ValueIteratorBase
isStarted	include/CppJieba/Limonp/Thread.hpp	/^            bool isStarted;$/;"	m	class:Limonp::IThread
isUserDictSingleChineseWord	include/CppJieba/DictTrie.hpp	/^            bool isUserDictSingleChineseWord(const Unicode::value_type& word) const$/;"	f	class:CppJieba::DictTrie
isUserDictSingleChineseWord	include/CppJieba/MPSegment.hpp	/^            bool isUserDictSingleChineseWord(const Unicode::value_type & value) const$/;"	f	class:CppJieba::MPSegment
itemCount_	include/json/value.h	/^      BucketIndex itemCount_;$/;"	m	class:Json::ValueInternalMap
itemIndex_	include/json/value.h	/^         BucketIndex itemIndex_;$/;"	m	struct:Json::ValueInternalMap::IteratorState
itemPerLink	include/json/value.h	/^      enum { itemPerLink = 6 };  \/\/ sizeof(ValueInternalLink) = 128 on 32 bits architecture.$/;"	e	enum:Json::ValueInternalLink::__anon4
itemsPerPage	include/json/value.h	/^      enum { itemsPerPage = 8 };    \/\/ should be a power of 2 for fast divide and modulo.$/;"	e	enum:Json::ValueInternalArray::__anon5
items_	include/json/value.h	/^      Value items_[itemPerLink];$/;"	m	class:Json::ValueInternalLink
iterator	include/json/value.h	/^      typedef ValueIterator iterator;$/;"	t	class:Json::Value
iterator_	include/json/value.h	/^      } iterator_;$/;"	m	class:Json::ValueIteratorBase	typeref:union:Json::ValueIteratorBase::__anon6
join	include/CppJieba/Limonp/StringUtil.hpp	/^        string join(T begin, T end, const string& connector)$/;"	f	namespace:Limonp
join	include/CppJieba/Limonp/StringUtil.hpp	/^        void join(T begin, T end, string& res, const string& connector)$/;"	f	namespace:Limonp
join	include/CppJieba/Limonp/Thread.hpp	/^            void join()$/;"	f	class:Limonp::IThread
join	src/Thread.cpp	/^void Thread::join(pthread_t &tid){$/;"	f	class:Thread
key_	include/json/value.h	/^      std::string key_;$/;"	m	class:Json::PathArgument
keys_	include/json/value.h	/^      char *keys_[itemPerLink];$/;"	m	class:Json::ValueInternalLink
kindIndex	include/json/value.h	/^         kindIndex,$/;"	e	enum:Json::PathArgument::Kind
kindKey	include/json/value.h	/^         kindKey$/;"	e	enum:Json::PathArgument::Kind
kindNone	include/json/value.h	/^         kindNone = 0,$/;"	e	enum:Json::PathArgument::Kind
kind_	include/json/value.h	/^      Kind kind_;$/;"	m	class:Json::PathArgument
lastValueEnd_	include/json/reader.h	/^      Location lastValueEnd_;$/;"	m	class:Json::Reader
lastValue_	include/json/reader.h	/^      Value *lastValue_;$/;"	m	class:Json::Reader
link_	include/json/value.h	/^         ValueInternalLink *link_;$/;"	m	struct:Json::ValueInternalMap::IteratorState
loadDiction	src/Diction.cpp	/^bool Diction::loadDiction(){$/;"	f	class:Diction
loadFile_	include/CppJieba/Limonp/Config.hpp	/^            void loadFile_(const string& filePath)$/;"	f	class:Limonp::Config
loadIndex	src/Index.cpp	/^bool Index::loadIndex(){$/;"	f	class:Index
lock	debug/condition_test.cpp	/^static MutexLock lock;$/;"	v	file:
lock	include/CppJieba/Limonp/MutexLock.hpp	/^            void lock()$/;"	f	class:Limonp::MutexLock
lock	include/Lock.h	/^    void lock(const int flag = _READLOCK){$/;"	f	class:MutexLock
lock	include/Lock.h	/^    void lock(const int flag = _READLOCK){$/;"	f	class:RWLock
loss_32	include/CppJieba/Limonp/CastFloat.hpp	/^        static const int loss_32 = 0x38000000;$/;"	m	namespace:Limonp::CastFloat
lower	include/CppJieba/Limonp/StringUtil.hpp	/^    inline string& lower(string& str)$/;"	f	namespace:Limonp
ltrim	include/CppJieba/Limonp/StringUtil.hpp	/^    inline std::string & ltrim(std::string & s, char x)$/;"	f	namespace:Limonp
ltrim	include/CppJieba/Limonp/StringUtil.hpp	/^    inline std::string &ltrim(std::string &s) $/;"	f	namespace:Limonp
main	debug/Diction_Test.cpp	/^int main(){$/;"	f
main	debug/Index_test.cpp	/^int main(){$/;"	f
main	debug/Query_test.cpp	/^int  main(){$/;"	f
main	debug/ThreadPool_test.cpp	/^int main(){$/;"	f
main	debug/cleanToken_test.cpp	/^int main()$/;"	f
main	debug/condition_test.cpp	/^int main(){$/;"	f
main	debug/config_test.cpp	/^int main(){$/;"	f
main	debug/editdistance_test.cpp	/^int main(){$/;"	f
main	debug/encoding_test.cpp	/^int main(){$/;"	f
main	debug/fork_client.cpp	/^int main(){$/;"	f
main	debug/log_test.cpp	/^int main(){$/;"	f
main	debug/splitUtf8_test.cpp	/^int main(){$/;"	f
main	debug/test_switch.cpp	/^int main(){$/;"	f
main	debug/vsnprintf_test.cpp	/^int main(){$/;"	f
main	src/DictionBuilder.cpp	/^int main(){$/;"	f
main	src/IndexBuilder.cpp	/^int main(){$/;"	f
main	src/fork_server.cpp	/^int main(){$/;"	f
mantissa_16	include/CppJieba/Limonp/CastFloat.hpp	/^        static const short mantissa_16 = (short)0x03FF;$/;"	m	namespace:Limonp::CastFloat
mantissa_32	include/CppJieba/Limonp/CastFloat.hpp	/^        static const int mantissa_32 = 0x007FE000;$/;"	m	namespace:Limonp::CastFloat
map_	include/CppJieba/Limonp/Config.hpp	/^            map<string, string> map_;$/;"	m	class:Limonp::Config
map_	include/json/value.h	/^         ObjectValues *map_;$/;"	m	union:Json::Value::ValueHolder
map_	include/json/value.h	/^         ValueInternalMap *map_;$/;"	m	struct:Json::ValueInternalMap::IteratorState
map_	include/json/value.h	/^         ValueInternalMap *map_;$/;"	m	union:Json::Value::ValueHolder
map_	include/json/value.h	/^         ValueInternalMap::IteratorState map_;$/;"	m	union:Json::ValueIteratorBase::__anon6
maxInt	include/json/value.h	/^      static const Int maxInt;$/;"	m	class:Json::Value
maxUInt	include/json/value.h	/^      static const UInt maxUInt;$/;"	m	class:Json::Value
md5File	include/CppJieba/Limonp/Md5.hpp	/^inline bool md5File(const char* filepath, std::string& res)$/;"	f	namespace:Limonp
md5String	include/CppJieba/Limonp/Md5.hpp	/^inline bool md5String(const char* str, std::string& res)$/;"	f	namespace:Limonp
message_	include/json/reader.h	/^         std::string message_;$/;"	m	class:Json::Reader::ErrorInfo
minInt	include/json/value.h	/^      static const Int minInt;$/;"	m	class:Json::Value
mpss_	include/CppJieba/Limonp/ArgvContext.hpp	/^            map<string, string> mpss_;$/;"	m	class:Limonp::ArgvContext
mutex_	include/CppJieba/Limonp/BlockingQueue.hpp	/^                mutable MutexLock          mutex_;$/;"	m	class:Limonp::BoundedBlockingQueue
mutex_	include/CppJieba/Limonp/BlockingQueue.hpp	/^                mutable MutexLock mutex_;$/;"	m	class:Limonp::BlockingQueue
mutex_	include/CppJieba/Limonp/Condition.hpp	/^            MutexLock& mutex_;$/;"	m	class:Limonp::Condition
mutex_	include/CppJieba/Limonp/MutexLock.hpp	/^            MutexLock & mutex_;$/;"	m	class:Limonp::MutexLockGuard
mutex_	include/CppJieba/Limonp/MutexLock.hpp	/^            pthread_mutex_t mutex_;$/;"	m	class:Limonp::MutexLock
nextPos	include/CppJieba/MPSegment.hpp	/^        size_t nextPos;$/;"	m	struct:CppJieba::SegmentChar
next_	include/json/value.h	/^      ValueInternalLink *next_;$/;"	m	class:Json::ValueInternalLink
noDuplication	include/json/value.h	/^            noDuplication = 0,$/;"	e	enum:Json::Value::CZString::DuplicationPolicy
nodes_	include/json/reader.h	/^      Nodes nodes_;$/;"	m	class:Json::Reader
notEmpty_	include/CppJieba/Limonp/BlockingQueue.hpp	/^                Condition                  notEmpty_;$/;"	m	class:Limonp::BoundedBlockingQueue
notEmpty_	include/CppJieba/Limonp/BlockingQueue.hpp	/^                Condition         notEmpty_;$/;"	m	class:Limonp::BlockingQueue
notFull_	include/CppJieba/Limonp/BlockingQueue.hpp	/^                Condition                  notFull_;$/;"	m	class:Limonp::BoundedBlockingQueue
notify	include/CppJieba/Limonp/Condition.hpp	/^            void notify()$/;"	f	class:Limonp::Condition
notifyAll	include/CppJieba/Limonp/Condition.hpp	/^            void notifyAll()$/;"	f	class:Limonp::Condition
null	include/json/value.h	/^      static const Value null;$/;"	m	class:Json::Value
nullValue	include/json/value.h	/^      nullValue = 0, \/\/\/< 'null' value$/;"	e	enum:Json::ValueType
numberOfCommentPlacement	include/json/value.h	/^      numberOfCommentPlacement$/;"	e	enum:Json::CommentPlacement
objectValue	include/json/value.h	/^      objectValue    \/\/\/< object value (collection of name\/value pairs).$/;"	e	enum:Json::ValueType
openPool	src/ThreadPool.cpp	/^void ThreadPool::openPool(){$/;"	f	class:ThreadPool
operator !=	include/json/value.h	/^      bool operator !=( const SelfType &other ) const$/;"	f	class:Json::ValueIteratorBase
operator *	include/json/value.h	/^      reference operator *() const$/;"	f	class:Json::ValueConstIterator
operator *	include/json/value.h	/^      reference operator *() const$/;"	f	class:Json::ValueIterator
operator ++	include/json/value.h	/^      SelfType &operator++()$/;"	f	class:Json::ValueConstIterator
operator ++	include/json/value.h	/^      SelfType &operator++()$/;"	f	class:Json::ValueIterator
operator ++	include/json/value.h	/^      SelfType operator++( int )$/;"	f	class:Json::ValueConstIterator
operator ++	include/json/value.h	/^      SelfType operator++( int )$/;"	f	class:Json::ValueIterator
operator -	include/json/value.h	/^      difference_type operator -( const SelfType &other ) const$/;"	f	class:Json::ValueIteratorBase
operator --	include/json/value.h	/^      SelfType &operator--()$/;"	f	class:Json::ValueConstIterator
operator --	include/json/value.h	/^      SelfType &operator--()$/;"	f	class:Json::ValueIterator
operator --	include/json/value.h	/^      SelfType operator--( int )$/;"	f	class:Json::ValueConstIterator
operator --	include/json/value.h	/^      SelfType operator--( int )$/;"	f	class:Json::ValueIterator
operator <	include/Query.h	/^    friend bool operator<(const HeapData4Query& l,const HeapData4Query& r){$/;"	f	class:HeapData4Query
operator <<	include/CppJieba/DictTrie.hpp	/^    inline ostream & operator << (ostream& os, const DictUnit& unit)$/;"	f	namespace:CppJieba
operator <<	include/CppJieba/Limonp/ArgvContext.hpp	/^    inline ostream& operator << (ostream& os, const ArgvContext& args)$/;"	f	namespace:Limonp
operator <<	include/CppJieba/Limonp/Config.hpp	/^    inline ostream& operator << (ostream& os, const Config& config)$/;"	f	namespace:Limonp
operator <<	include/CppJieba/Limonp/LocalVector.hpp	/^        ostream & operator << (ostream& os, const LocalVector<T>& vec)$/;"	f	namespace:Limonp
operator <<	include/CppJieba/Limonp/StdExtension.hpp	/^        basic_string<T> & operator << (basic_string<T> & s, ifstream & ifs)$/;"	f	namespace:std
operator <<	include/CppJieba/Limonp/StdExtension.hpp	/^        ofstream & operator << (ofstream & ofs, const basic_string<T>& s)$/;"	f	namespace:std
operator <<	include/CppJieba/Limonp/StdExtension.hpp	/^        ostream& operator << (ostream& os, const map<T1, T2>& mp)$/;"	f	namespace:std
operator <<	include/CppJieba/Limonp/StdExtension.hpp	/^        ostream& operator << (ostream& os, const pair<T1, T2>& pr)$/;"	f	namespace:std
operator <<	include/CppJieba/Limonp/StdExtension.hpp	/^        ostream& operator << (ostream& os, const set<T>& st)$/;"	f	namespace:std
operator <<	include/CppJieba/Limonp/StdExtension.hpp	/^        ostream& operator << (ostream& os, const std::unordered_map<T1, T2>& mp)$/;"	f	namespace:std
operator <<	include/CppJieba/Limonp/StdExtension.hpp	/^        ostream& operator << (ostream& os, const vector<T>& vec)$/;"	f	namespace:std
operator <<	include/CppJieba/Limonp/StdExtension.hpp	/^        string& operator << (string& str, const T& obj)$/;"	f	namespace:std
operator =	include/CppJieba/Limonp/LocalVector.hpp	/^                LocalVector<T>& operator = (const LocalVector<T>& vec)$/;"	f	class:Limonp::LocalVector
operator ==	include/json/value.h	/^      bool operator ==( const SelfType &other ) const$/;"	f	class:Json::ValueIteratorBase
operator []	include/CppJieba/Limonp/ArgvContext.hpp	/^            string operator [](const string& key) const$/;"	f	class:Limonp::ArgvContext
operator []	include/CppJieba/Limonp/ArgvContext.hpp	/^            string operator [](size_t i) const$/;"	f	class:Limonp::ArgvContext
operator []	include/CppJieba/Limonp/Config.hpp	/^            const char* operator [] (const char* key) const$/;"	f	class:Limonp::Config
operator []	include/CppJieba/Limonp/LocalVector.hpp	/^                T& operator [] (size_t i) $/;"	f	class:Limonp::LocalVector
operator []	include/CppJieba/Limonp/LocalVector.hpp	/^                const T& operator [] (size_t i) const$/;"	f	class:Limonp::LocalVector
operator bool	include/CppJieba/Limonp/Config.hpp	/^            operator bool ()$/;"	f	class:Limonp::Config
operator bool	include/CppJieba/Limonp/InitOnOff.hpp	/^            operator bool() const {return getInitFlag_();};$/;"	f	class:Limonp::InitOnOff
operator const char *	include/json/value.h	/^      operator const char *() const$/;"	f	class:Json::StaticString
pInfo	include/CppJieba/MPSegment.hpp	/^        const DictUnit * pInfo;$/;"	m	struct:CppJieba::SegmentChar
pageCount_	include/json/value.h	/^      PageIndex pageCount_;$/;"	m	class:Json::ValueInternalArray
pages_	include/json/value.h	/^      Value **pages_;$/;"	m	class:Json::ValueInternalArray
passwd_	include/CppJieba/Limonp/MysqlClient.hpp	/^            const string passwd_;$/;"	m	class:Limonp::MysqlClient
pcond_	include/CppJieba/Limonp/Condition.hpp	/^            pthread_cond_t pcond_;$/;"	m	class:Limonp::Condition
pointer	include/json/value.h	/^      typedef Value *pointer;$/;"	t	class:Json::ValueIterator
pointer	include/json/value.h	/^      typedef const Value *pointer;$/;"	t	class:Json::ValueConstIterator
pop	include/CppJieba/Limonp/BlockingQueue.hpp	/^                T pop()$/;"	f	class:Limonp::BlockingQueue
pop	include/CppJieba/Limonp/BlockingQueue.hpp	/^                T pop()$/;"	f	class:Limonp::BoundedBlockingQueue
pop	include/CppJieba/Limonp/BoundedQueue.hpp	/^                T pop()$/;"	f	class:Limonp::BoundedQueue
port_	include/CppJieba/Limonp/MysqlClient.hpp	/^            const size_t port_;$/;"	m	class:Limonp::MysqlClient
previous_	include/json/value.h	/^      ValueInternalLink *previous_;$/;"	m	class:Json::ValueInternalLink
print	include/CppJieba/Limonp/HandyMacro.hpp	10;"	d
ptKeyMap	include/CppJieba/Trie.hpp	/^                KeyMapType * ptKeyMap;$/;"	m	class:CppJieba::TrieNode
ptThreadPool_	include/CppJieba/Limonp/ThreadPool.hpp	/^                    ThreadPool * ptThreadPool_;$/;"	m	class:Limonp::ThreadPool::Worker
ptValue	include/CppJieba/Trie.hpp	/^                const ValueType * ptValue;$/;"	m	class:CppJieba::TrieNode
ptr_	include/CppJieba/Limonp/LocalVector.hpp	/^                T * ptr_;$/;"	m	class:Limonp::LocalVector
push	include/CppJieba/Limonp/BlockingQueue.hpp	/^                void push(const T& x)$/;"	f	class:Limonp::BlockingQueue
push	include/CppJieba/Limonp/BlockingQueue.hpp	/^                void push(const T& x)$/;"	f	class:Limonp::BoundedBlockingQueue
push	include/CppJieba/Limonp/BoundedQueue.hpp	/^                void push(const T& t)$/;"	f	class:Limonp::BoundedQueue
push_back	include/CppJieba/Limonp/LocalVector.hpp	/^                void push_back(const T& t)$/;"	f	class:Limonp::LocalVector
queue_	include/CppJieba/Limonp/BlockingQueue.hpp	/^                BoundedQueue<T>  queue_;$/;"	m	class:Limonp::BoundedBlockingQueue
queue_	include/CppJieba/Limonp/BlockingQueue.hpp	/^                std::queue<T>     queue_;$/;"	m	class:Limonp::BlockingQueue
queue_	include/CppJieba/Limonp/ThreadPool.hpp	/^            BoundedBlockingQueue<ITask*> queue_;$/;"	m	class:Limonp::ThreadPool
readFileToMap	src/DictionBuilder.cpp	/^void readFileToMap(const char* filename,CppJieba::MixSegment &seg){$/;"	f
readLock	include/Lock.h	/^    void readLock(){$/;"	f	class:RWLock
realValue	include/json/value.h	/^      realValue,     \/\/\/< double value$/;"	e	enum:Json::ValueType
real_	include/json/value.h	/^         double real_;$/;"	m	union:Json::Value::ValueHolder
reference	include/json/value.h	/^      typedef Value &reference;$/;"	t	class:Json::ValueIterator
reference	include/json/value.h	/^      typedef const Value &reference;$/;"	t	class:Json::ValueConstIterator
regeditPool	src/WorkThread.cpp	/^void WorkThread::regeditPool(ThreadPool* p_pool){$/;"	f	class:WorkThread
reserve	include/CppJieba/Limonp/LocalVector.hpp	/^                void reserve(size_t size) $/;"	f	class:Limonp::LocalVector
rightMargin_	include/json/writer.h	/^      int rightMargin_;$/;"	m	class:Json::StyledStreamWriter
rightMargin_	include/json/writer.h	/^      int rightMargin_;$/;"	m	class:Json::StyledWriter
rtrim	include/CppJieba/Limonp/StringUtil.hpp	/^    inline std::string & rtrim(std::string & s, char x)$/;"	f	namespace:Limonp
rtrim	include/CppJieba/Limonp/StringUtil.hpp	/^    inline std::string &rtrim(std::string &s) $/;"	f	namespace:Limonp
run	include/CppJieba/Limonp/ThreadPool.hpp	/^                    virtual void run()$/;"	f	class:Limonp::ThreadPool::Worker
saveIndex	src/IndexBuilder.cpp	/^bool saveIndex(){$/;"	f
select	include/CppJieba/Limonp/MysqlClient.hpp	/^            bool select(const string& sql, RowsType& rows)$/;"	f	class:Limonp::MysqlClient
setInitFlag_	include/CppJieba/Limonp/InitOnOff.hpp	/^            bool setInitFlag_(bool flag){return isInited_ = flag;};$/;"	f	class:Limonp::InitOnOff
setItemUsed	include/json/value.h	/^      inline void setItemUsed( bool isUsed = true )$/;"	f	class:Json::Value
setMemberNameIsStatic	include/json/value.h	/^      inline void setMemberNameIsStatic( bool isStatic )$/;"	f	class:Json::Value
setThreadId	include/Thread.h	/^    void setThreadId(pthread_t &tid){$/;"	f	class:Thread
shortBitsToFloat	include/CppJieba/Limonp/CastFloat.hpp	/^        inline float shortBitsToFloat(short s)$/;"	f	namespace:Limonp::CastFloat
sign_16	include/CppJieba/Limonp/CastFloat.hpp	/^        static const short sign_16 = (short)0xC000;$/;"	m	namespace:Limonp::CastFloat
sign_32	include/CppJieba/Limonp/CastFloat.hpp	/^        static const int sign_32 = 0xC0000000;$/;"	m	namespace:Limonp::CastFloat
sign_exponent_16	include/CppJieba/Limonp/CastFloat.hpp	/^        static const short sign_exponent_16 = (short)0x4000;$/;"	m	namespace:Limonp::CastFloat
sign_exponent_32	include/CppJieba/Limonp/CastFloat.hpp	/^        static const int sign_exponent_32 = 0x40000000;$/;"	m	namespace:Limonp::CastFloat
size	include/CppJieba/Limonp/BlockingQueue.hpp	/^                size_t size() const$/;"	f	class:Limonp::BlockingQueue
size	include/CppJieba/Limonp/BlockingQueue.hpp	/^                size_t size() const$/;"	f	class:Limonp::BoundedBlockingQueue
size	include/CppJieba/Limonp/BoundedQueue.hpp	/^                size_t size() const$/;"	f	class:Limonp::BoundedQueue
size	include/CppJieba/Limonp/LocalVector.hpp	/^                size_t size() const$/;"	f	class:Limonp::LocalVector
size_	include/CppJieba/Limonp/BoundedQueue.hpp	/^                size_t size_;$/;"	m	class:Limonp::BoundedQueue
size_	include/CppJieba/Limonp/LocalVector.hpp	/^                size_t size_;$/;"	m	class:Limonp::LocalVector
size_	include/json/value.h	/^      ArrayIndex size_;$/;"	m	class:Json::ValueInternalArray
size_t	include/json/value.h	/^      typedef unsigned int size_t;$/;"	t	class:Json::ValueConstIterator
size_t	include/json/value.h	/^      typedef unsigned int size_t;$/;"	t	class:Json::ValueIterator
size_t	include/json/value.h	/^      typedef unsigned int size_t;$/;"	t	class:Json::ValueIteratorBase
size_type	include/CppJieba/Limonp/LocalVector.hpp	/^                typedef size_t size_type;$/;"	t	class:Limonp::LocalVector
split	include/CppJieba/Limonp/StringUtil.hpp	/^    inline bool split(const string& src, vector<string>& res, const string& pattern, size_t offset = 0, size_t len = string::npos)$/;"	f	namespace:Limonp
splitIntoLetters	debug/splitUtf8_test.cpp	/^void splitIntoLetters(const string& key_word,vector<string>& letters_vec){$/;"	f
splitIntoLetters	include/string_tools.h	/^void splitIntoLetters(const std::string& key_word,std::vector<string>& letters_vec){$/;"	f
sset_	include/CppJieba/Limonp/ArgvContext.hpp	/^            set<string> sset_; $/;"	m	class:Limonp::ArgvContext
start	include/CppJieba/Limonp/Thread.hpp	/^            void start()$/;"	f	class:Limonp::IThread
start	include/CppJieba/Limonp/ThreadPool.hpp	/^            void start()$/;"	f	class:Limonp::ThreadPool
start	script/excute.sh	/^function start $/;"	f
start	script/excute.sh~	/^function start $/;"	f
start	src/Thread.cpp	/^void Thread::start(){$/;"	f	class:Thread
start_	include/json/reader.h	/^         Location start_;$/;"	m	class:Json::Reader::Token
startsWith	include/CppJieba/Limonp/StringUtil.hpp	/^    inline bool startsWith(const string& str, const string& prefix)$/;"	f	namespace:Limonp
stat	script/excute.sh	/^function stat$/;"	f
stat	script/excute.sh~	/^function stat$/;"	f
state	include/CppJieba/Limonp/Md5.hpp	/^    UINT4 state[4];                                   \/* state (ABCD) *\/$/;"	m	struct:Limonp::MD5::__context_t
std	include/CppJieba/Limonp/StdExtension.hpp	/^namespace std$/;"	n
stop	script/excute.sh	/^function stop$/;"	f
stop	script/excute.sh~	/^function stop$/;"	f
str_	include/json/value.h	/^      const char *str_;$/;"	m	class:Json::StaticString
str_into_vector	include/edit_distance.h	/^bool str_into_vector(const std::string& str,std::vector<uint32_t>& vec){$/;"	f
strictRoot_	include/json/features.h	/^      bool strictRoot_;$/;"	m	class:Json::Features
stringValue	include/json/value.h	/^      stringValue,   \/\/\/< UTF-8 string value$/;"	e	enum:Json::ValueType
string_	include/json/value.h	/^         char *string_;$/;"	m	union:Json::Value::ValueHolder
string_format	include/CppJieba/Limonp/StringUtil.hpp	/^    inline string string_format(const char* fmt, ...) $/;"	f	namespace:Limonp
tag	include/CppJieba/DictTrie.hpp	/^        string tag;$/;"	m	struct:CppJieba::DictUnit
tag	include/CppJieba/PosTagger.hpp	/^            bool tag(const string& src, vector<pair<string, string> >& res)$/;"	f	class:CppJieba::PosTagger
tailLink_	include/json/value.h	/^      ValueInternalLink *tailLink_;$/;"	m	class:Json::ValueInternalMap
tail_	include/CppJieba/Limonp/BoundedQueue.hpp	/^                size_t tail_;$/;"	m	class:Limonp::BoundedQueue
thread_	include/CppJieba/Limonp/Thread.hpp	/^            pthread_t thread_;$/;"	m	class:Limonp::IThread
thread_func	src/Thread.cpp	/^void* Thread::thread_func(void *arg){$/;"	f	class:Thread
threads_	include/CppJieba/Limonp/ThreadPool.hpp	/^            vector<IThread*> threads_;$/;"	m	class:Limonp::ThreadPool
tokenArrayBegin	include/json/reader.h	/^         tokenArrayBegin,$/;"	e	enum:Json::Reader::TokenType
tokenArrayEnd	include/json/reader.h	/^         tokenArrayEnd,$/;"	e	enum:Json::Reader::TokenType
tokenArraySeparator	include/json/reader.h	/^         tokenArraySeparator,$/;"	e	enum:Json::Reader::TokenType
tokenComment	include/json/reader.h	/^         tokenComment,$/;"	e	enum:Json::Reader::TokenType
tokenEndOfStream	include/json/reader.h	/^         tokenEndOfStream = 0,$/;"	e	enum:Json::Reader::TokenType
tokenError	include/json/reader.h	/^         tokenError$/;"	e	enum:Json::Reader::TokenType
tokenFalse	include/json/reader.h	/^         tokenFalse,$/;"	e	enum:Json::Reader::TokenType
tokenMemberSeparator	include/json/reader.h	/^         tokenMemberSeparator,$/;"	e	enum:Json::Reader::TokenType
tokenNull	include/json/reader.h	/^         tokenNull,$/;"	e	enum:Json::Reader::TokenType
tokenNumber	include/json/reader.h	/^         tokenNumber,$/;"	e	enum:Json::Reader::TokenType
tokenObjectBegin	include/json/reader.h	/^         tokenObjectBegin,$/;"	e	enum:Json::Reader::TokenType
tokenObjectEnd	include/json/reader.h	/^         tokenObjectEnd,$/;"	e	enum:Json::Reader::TokenType
tokenString	include/json/reader.h	/^         tokenString,$/;"	e	enum:Json::Reader::TokenType
tokenTrue	include/json/reader.h	/^         tokenTrue,$/;"	e	enum:Json::Reader::TokenType
token_	include/json/reader.h	/^         Token token_;$/;"	m	class:Json::Reader::ErrorInfo
traverseDir	src/DictionBuilder.cpp	/^void traverseDir(const char *row_path,CppJieba::MixSegment& seg)$/;"	f
trim	include/CppJieba/Limonp/StringUtil.hpp	/^    inline std::string &trim(std::string &s) $/;"	f	namespace:Limonp
trim	include/CppJieba/Limonp/StringUtil.hpp	/^    inline std::string &trim(std::string &s, char x)$/;"	f	namespace:Limonp
tryLock	include/Lock.h	/^    void tryLock(){$/;"	f	class:MutexLock
tryReadLock	include/Lock.h	/^    void tryReadLock(){$/;"	f	class:RWLock
tryWriteLock	include/Lock.h	/^    void tryWriteLock(){$/;"	f	class:RWLock
twocharToUint16	include/CppJieba/Limonp/StringUtil.hpp	/^    inline uint16_t twocharToUint16(char high, char low)$/;"	f	namespace:Limonp
type_	include/json/reader.h	/^         TokenType type_;$/;"	m	class:Json::Reader::Token
uintValue	include/json/value.h	/^      uintValue,     \/\/\/< unsigned integer value$/;"	e	enum:Json::ValueType
uint_	include/json/value.h	/^         UInt uint_;$/;"	m	union:Json::Value::ValueHolder
uniCh	include/CppJieba/MPSegment.hpp	/^        uint16_t uniCh;$/;"	m	struct:CppJieba::SegmentChar
unicodeToUtf8	include/CppJieba/Limonp/StringUtil.hpp	/^    bool unicodeToUtf8(Uint16ContainerConIter begin, Uint16ContainerConIter end, string& res)$/;"	f	namespace:Limonp
unknown	include/json/value.h	/^      enum { unknown = (unsigned)-1 };$/;"	e	enum:Json::ValueAllocator::__anon3
unlock	include/CppJieba/Limonp/MutexLock.hpp	/^            void unlock()$/;"	f	class:Limonp::MutexLock
unlock	include/Lock.h	/^    void unlock(){$/;"	f	class:MutexLock
unlock	include/Lock.h	/^    void unlock(){$/;"	f	class:RWLock
upper	include/CppJieba/Limonp/StringUtil.hpp	/^    inline string& upper(string& str)$/;"	f	namespace:Limonp
user_	include/CppJieba/Limonp/MysqlClient.hpp	/^            const string user_;$/;"	m	class:Limonp::MysqlClient
utf8ToUnicode	include/CppJieba/Limonp/StringUtil.hpp	/^    bool utf8ToUnicode(const char * const str, size_t len, Uint16Container& vec)$/;"	f	namespace:Limonp
utf8ToUnicode	include/CppJieba/Limonp/StringUtil.hpp	/^    bool utf8ToUnicode(const string& str, Uint16Container& vec)$/;"	f	namespace:Limonp
utf8_gbk	include/EncodingConverter.hpp	/^bool utf8_gbk(string instr,string& outstr)$/;"	f
value_	include/json/value.h	/^      } value_;$/;"	m	class:Json::Value	typeref:union:Json::Value::ValueHolder
value_type	include/CppJieba/Limonp/LocalVector.hpp	/^                typedef T value_type;$/;"	t	class:Limonp::LocalVector
wait	include/Condition.h	/^    void wait(){$/;"	f	class:Condition
wait	include/CppJieba/Limonp/Condition.hpp	/^            void wait()$/;"	f	class:Limonp::Condition
waitChild	src/fork_server.cpp	/^void waitChild(int signo){$/;"	f
wakeUp	include/Condition.h	/^    void wakeUp(){$/;"	f	class:Condition
wakeUpAll	include/Condition.h	/^    void wakeUpAll(){$/;"	f	class:Condition
weight	include/CppJieba/DictTrie.hpp	/^        double weight; $/;"	m	struct:CppJieba::DictUnit
weight	include/CppJieba/MPSegment.hpp	/^        double weight;$/;"	m	struct:CppJieba::SegmentChar
word	include/CppJieba/DictTrie.hpp	/^        Unicode word;$/;"	m	struct:CppJieba::DictUnit
worker_	include/CppJieba/Limonp/Thread.hpp	/^            static void * worker_(void * data)$/;"	f	class:Limonp::IThread
workking	src/WorkThread.cpp	/^void WorkThread::workking(){$/;"	f	class:WorkThread
writeLock	include/Lock.h	/^    void writeLock(){$/;"	f	class:RWLock
writeToString	include/CppJieba/Limonp/Md5.hpp	/^  void writeToString()$/;"	f	class:Limonp::MD5
yamlCompatiblityEnabled_	include/json/writer.h	/^      bool yamlCompatiblityEnabled_;$/;"	m	class:Json::FastWriter
~ArgvContext	include/CppJieba/Limonp/ArgvContext.hpp	/^            ~ArgvContext(){};$/;"	f	class:Limonp::ArgvContext
~BoundedQueue	include/CppJieba/Limonp/BoundedQueue.hpp	/^                ~BoundedQueue(){}$/;"	f	class:Limonp::BoundedQueue
~CodeConverter	include/CppJieba/Limonp/CodeConverter.hpp	/^            ~CodeConverter() $/;"	f	class:Limonp::CodeConverter
~Condition	include/Condition.h	/^    ~Condition(){$/;"	f	class:Condition
~Condition	include/CppJieba/Limonp/Condition.hpp	/^            ~Condition()$/;"	f	class:Limonp::Condition
~Configure	include/Configure.h	/^    ~Configure(){}$/;"	f	class:Configure
~DictTrie	include/CppJieba/DictTrie.hpp	/^            ~DictTrie()$/;"	f	class:CppJieba::DictTrie
~Diction	src/Diction.cpp	/^Diction::~Diction(){$/;"	f	class:Diction
~FastWriter	include/json/writer.h	/^      virtual ~FastWriter(){}$/;"	f	class:Json::FastWriter
~FullSegment	include/CppJieba/FullSegment.hpp	/^            virtual ~FullSegment()$/;"	f	class:CppJieba::FullSegment
~HMMSegment	include/CppJieba/HMMSegment.hpp	/^            virtual ~HMMSegment(){}$/;"	f	class:CppJieba::HMMSegment
~ISegment	include/CppJieba/ISegment.hpp	/^            virtual ~ISegment(){};$/;"	f	class:CppJieba::ISegment
~ITask	include/CppJieba/Limonp/ThreadPool.hpp	/^            virtual ~ITask() {}$/;"	f	class:Limonp::ITask
~IThread	include/CppJieba/Limonp/Thread.hpp	/^            virtual ~IThread()$/;"	f	class:Limonp::IThread
~Index	src/Index.cpp	/^Index::~Index(){$/;"	f	class:Index
~InitOnOff	include/CppJieba/Limonp/InitOnOff.hpp	/^            ~InitOnOff(){};$/;"	f	class:Limonp::InitOnOff
~KeywordExtractor	include/CppJieba/KeywordExtractor.hpp	/^            ~KeywordExtractor(){};$/;"	f	class:CppJieba::KeywordExtractor
~LocalVector	include/CppJieba/Limonp/LocalVector.hpp	/^                ~LocalVector()$/;"	f	class:Limonp::LocalVector
~LockBase	include/Lock.h	/^    virtual ~LockBase(){}$/;"	f	class:LockBase
~LockSafeGuard	include/Lock.h	/^    ~LockSafeGuard(){$/;"	f	class:LockSafeGuard
~MPSegment	include/CppJieba/MPSegment.hpp	/^            virtual ~MPSegment(){};$/;"	f	class:CppJieba::MPSegment
~MixSegment	include/CppJieba/MixSegment.hpp	/^            virtual ~MixSegment(){}$/;"	f	class:CppJieba::MixSegment
~MutexLock	include/CppJieba/Limonp/MutexLock.hpp	/^            ~MutexLock()$/;"	f	class:Limonp::MutexLock
~MutexLock	include/Lock.h	/^    ~MutexLock(){$/;"	f	class:MutexLock
~MutexLockGuard	include/CppJieba/Limonp/MutexLock.hpp	/^            ~MutexLockGuard()$/;"	f	class:Limonp::MutexLockGuard
~MysqlClient	include/CppJieba/Limonp/MysqlClient.hpp	/^            ~MysqlClient()$/;"	f	class:Limonp::MysqlClient
~NonCopyable	include/CppJieba/Limonp/NonCopyable.hpp	/^            ~NonCopyable(){};$/;"	f	class:Limonp::NonCopyable
~PosTagger	include/CppJieba/PosTagger.hpp	/^            ~PosTagger(){};$/;"	f	class:CppJieba::PosTagger
~Query	src/Query.cpp	/^Query::~Query(){}$/;"	f	class:Query
~QuerySegment	include/CppJieba/QuerySegment.hpp	/^        virtual ~QuerySegment(){};$/;"	f	class:CppJieba::QuerySegment
~RWLock	include/Lock.h	/^    ~RWLock(){$/;"	f	class:RWLock
~SegmentBase	include/CppJieba/SegmentBase.hpp	/^            virtual ~SegmentBase(){};$/;"	f	class:CppJieba::SegmentBase
~StyledStreamWriter	include/json/writer.h	/^      ~StyledStreamWriter(){}$/;"	f	class:Json::StyledStreamWriter
~StyledWriter	include/json/writer.h	/^      virtual ~StyledWriter(){}$/;"	f	class:Json::StyledWriter
~Thread	src/Thread.cpp	/^Thread::~Thread(){$/;"	f	class:Thread
~ThreadPool	include/CppJieba/Limonp/ThreadPool.hpp	/^            ~ThreadPool()$/;"	f	class:Limonp::ThreadPool
~ThreadPool	src/ThreadPool.cpp	/^ThreadPool::~ThreadPool(){$/;"	f	class:ThreadPool
~Trie	include/CppJieba/Trie.hpp	/^                ~Trie()$/;"	f	class:CppJieba::Trie
~Uncopyable	include/Uncopyable.h	/^    ~Uncopyable(){}$/;"	f	class:Uncopyable
~Worker	include/CppJieba/Limonp/ThreadPool.hpp	/^                    virtual ~Worker()$/;"	f	class:Limonp::ThreadPool::Worker
